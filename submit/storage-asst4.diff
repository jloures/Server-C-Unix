Index: census.txt
===================================================================
--- census.txt	(revision 0)
+++ census.txt	(revision 66)
@@ -0,0 +1,692 @@
+3520005,"Toronto (Ont.)",C  ,F,2503281,2481494,F,F,0.9,1040597,979330,630.1763,3972.4,1
+2466023,"Montréal (Que.)",V  ,F,1620693,1583590,T,F,2.3,787060,743204,365.1303,4438.7,2
+4806016,"Calgary (Alta.)",CY ,F,988193,879003,T,F,12.4,401389,384723,726.4954,1360.2,3
+3506008,"Ottawa (Ont.)",C  ,F,812129,774072,F,F,4.9,340732,320888,2778.1295,292.3,4
+4811061,"Edmonton (Alta.)",CY ,F,730372,666104,F,F,9.6,314362,297773,684.3739,1067.2,5
+3521005,"Mississauga (Ont.)",CY ,F,668549,612925,F,F,9.1,223737,214894,288.5299,2317.1,6
+4611040,"Winnipeg (Man.)",CY ,F,633451,619544,F,F,2.2,269586,261109,464.0060,1365.2,7
+5915022,"Vancouver (B.C.)",CY ,F,578041,545671,F,F,5.9,273804,253212,114.7133,5039.0,8
+3525005,"Hamilton (Ont.)",C  ,F,504559,490268,F,F,,204962,194475,1117.2065,451.6,9
+2423027,"Québec (Que.)",V  ,F,491142,476330,T,F,3.1,238423,228037,454.2641,1081.2,10
+3521010,"Brampton (Ont.)",CY ,F,433806,325428,F,F,33.3,130803,125934,266.7051,1626.5,11
+5915004,"Surrey (B.C.)",CY ,F,394976,347820,T,F,13.6,139193,131146,317.1851,1245.3,12
+1209034,"Halifax (N.S.)",RGM,F,372679,359111,F,F,3.8,166675,155060,5490.1817,67.9,13
+2465005,"Laval (Que.)",V  ,F,368709,343005,F,F,7.5,148146,144186,247.0907,1492.2,14
+3539036,"London (Ont.)",CY ,F,352395,336539,F,F,4.7,157436,145526,420.5719,837.9,15
+3519036,"Markham (Ont.)",T  ,F,261573,208615,F,F,25.4,81181,77191,212.5751,1230.5,16
+2481017,"Gatineau (Que.)",V  ,F,242124,226696,T,F,6.8,104607,100203,342.3157,707.3,17
+3519028,"Vaughan (Ont.)",CY ,F,238866,182022,F,F,31.2,71265,69536,273.5809,873.1,18
+2458227,"Longueuil (Que.)",V  ,F,229330,225761,T,F,1.6,101746,98735,115.5904,1984.0,19
+3537039,"Windsor (Ont.)",CY ,F,216473,209218,T,F,3.5,95049,88469,146.9142,1473.5,20
+3530013,"Kitchener (Ont.)",CY ,F,204668,190399,F,F,7.5,82723,79377,136.8854,1495.2,21
+5915025,"Burnaby (B.C.)",CY ,F,202799,193954,F,F,4.6,82950,78027,89.1176,2275.6,22
+4711066,"Saskatoon (Sask.)",CY ,F,202340,196861,T,F,2.8,89646,84384,170.8314,1184.4,23
+4706027,"Regina (Sask.)",CY ,F,179246,178225,F,F,0.6,78692,74803,118.8712,1507.9,24
+5915015,"Richmond (B.C.)",CY ,F,174461,164345,F,F,6.2,64367,61417,128.7589,1354.9,25
+3524001,"Oakville (Ont.)",T  ,F,165613,144738,F,F,14.4,58828,56528,138.5604,1195.2,26
+3524002,"Burlington (Ont.)",CY ,F,164415,150836,F,F,9.0,65340,63159,185.7403,885.2,27
+3519038,"Richmond Hill (Ont.)",T  ,F,162704,132030,F,F,23.2,53028,51000,100.8917,1612.7,28
+3553005,"Greater Sudbury / Grand Sudbury (Ont.)",C  ,F,157857,155219,F,F,1.7,69430,64940,3200.5632,49.3,29
+2443027,"Sherbrooke (Que.)",V  ,F,147427,138785,T,F,6.2,70444,65991,353.4647,417.1,30
+2494068,"Saguenay (Que.)",V  ,F,143692,147133,T,F,-2.3,63632,61274,1126.2674,127.6,31
+3518013,"Oshawa (Ont.)",CY ,F,141590,139051,F,F,1.8,57469,54923,145.6676,972.0,32
+3526053,"St. Catharines (Ont.)",CY ,F,131989,129170,F,F,2.2,57790,54730,96.1109,1373.3,33
+2425213,"Lévis (Que.)",V  ,F,130006,121999,T,F,6.6,54425,52625,449.3150,289.3,34
+3543042,"Barrie (Ont.)",CY ,F,128430,103710,F,F,23.8,48196,46533,76.9938,1668.1,35
+2437067,"Trois-Rivières (Que.)",V  ,F,126323,122395,T,F,3.2,60682,57557,288.9247,437.2,36
+5909052,"Abbotsford (B.C.)",CY ,F,123864,115494,T,F,7.2,45286,43564,359.3615,344.7,37
+3530010,"Cambridge (Ont.)",CY ,F,120371,110372,F,F,9.1,44589,43275,112.8645,1066.5,38
+3510010,"Kingston (Ont.)",CY ,F,117207,114195,F,F,2.6,53838,48863,450.3856,260.2,39
+3523008,"Guelph (Ont.)",CY ,F,114943,106170,F,F,8.3,47969,44706,86.7198,1325.5,40
+5915034,"Coquitlam (B.C.)",CY ,F,114565,112890,F,F,1.5,43241,41239,121.6892,941.5,41
+3518009,"Whitby (Ont.)",T  ,F,111184,87413,F,F,27.2,38129,37240,146.5247,758.8,42
+3558004,"Thunder Bay (Ont.)",CY ,F,109140,109016,F,F,0.1,49023,46266,328.4798,332.3,43
+5917021,"Saanich (B.C.)",DM ,F,108265,103654,F,F,4.4,48105,44513,103.4359,1046.7,44
+3536020,"Chatham-Kent (Ont.)",MU ,F,108177,107341,F,F,0.8,46614,43562,2458.0587,44.0,45
+5935010,"Kelowna (B.C.)",CY ,F,106707,96288,F,F,10.8,47727,44912,211.6919,504.1,46
+1217030,"Cape Breton (N.S.)",RGM,F,102250,105968,F,F,-3.5,45342,42026,2433.3260,42.0,47
+1001519,"St. John's (N.L.)",CY ,F,100646,99182,F,F,1.5,45317,41518,446.0430,225.6,48
+3530016,"Waterloo (Ont.)",CY ,F,97475,86543,F,F,12.6,40659,36779,64.1003,1520.7,49
+5915011,"Delta (B.C.)",DM ,F,96723,96950,F,F,-0.2,35125,33551,183.6984,526.5,50
+2464008,"Terrebonne (Que.)",V  ,F,94703,80536,T,F,17.6,35859,34820,154.5964,612.6,51
+5915001,"Langley (B.C.)",DM ,F,93726,86896,F,F,7.9,35098,33320,306.9257,305.4,52
+3529006,"Brantford (Ont.)",CY ,F,90192,86417,F,F,4.4,36963,35609,72.4719,1244.5,53
+3518005,"Ajax (Ont.)",T  ,F,90167,73753,F,F,22.3,29535,28616,67.0890,1344.0,54
+3518001,"Pickering (Ont.)",CY ,F,87838,87139,F,F,0.8,29044,28210,231.5934,379.3,55
+2456083,"Saint-Jean-sur-Richelieu (Que.)",V  ,F,87492,79600,T,F,9.9,37774,36700,225.7758,387.5,56
+4808011,"Red Deer (Alta.)",CY ,F,82772,67829,T,F,22.0,33894,32664,69.2321,1195.6,57
+5915046,"North Vancouver (B.C.)",DM ,F,82562,82310,F,F,0.3,30957,29749,160.6698,513.9,58
+4811052,"Strathcona County (Alta.)",SM ,F,82511,71986,F,F,14.6,29293,28647,1179.4273,70.0,59
+3526043,"Niagara Falls (Ont.)",CY ,F,82184,78815,F,F,4.3,33871,32482,209.5804,392.1,60
+5933042,"Kamloops (B.C.)",CY ,F,80376,77281,F,F,4.0,34163,32649,297.3020,270.4,61
+5921007,"Nanaimo (B.C.)",CY ,F,78692,73000,F,F,7.8,35042,33524,89.3018,881.2,62
+5917034,"Victoria (B.C.)",CY ,F,78057,74125,F,F,5.3,44783,41722,19.6840,3965.5,63
+3518017,"Clarington (Ont.)",MU ,F,77820,69834,F,F,11.4,27753,26865,611.0976,127.3,64
+2460013,"Repentigny (Que.)",V  ,F,76237,72218,T,F,5.6,30080,29393,61.7550,1234.5,65
+3557061,"Sault Ste. Marie (Ont.)",CY ,F,74948,74566,F,F,0.5,33378,31763,221.7132,338.0,66
+3515014,"Peterborough (Ont.)",CY ,F,74898,71446,F,F,4.8,33042,31204,58.3959,1282.6,67
+4802012,"Lethbridge (Alta.)",CY ,F,74637,67374,F,F,10.8,32900,30565,121.9722,611.9,68
+3516010,"Kawartha Lakes (Ont.)",CY ,F,74561,69179,F,F,7.8,37986,29509,3059.4747,24.4,69
+3519048,"Newmarket (Ont.)",T  ,F,74295,65788,F,F,12.9,25876,25087,38.0799,1951.0,70
+3538030,"Sarnia (Ont.)",CY ,F,71419,70876,F,F,0.8,31610,30114,164.6275,433.8,71
+2458007,"Brossard (Que.)",V  ,F,71154,65026,T,F,9.4,27530,26647,45.1970,1574.3,72
+5953023,"Prince George (B.C.)",CY ,F,70981,72406,F,F,-2.0,30062,28202,315.9973,224.6,73
+5909020,"Chilliwack (B.C.)",CY ,F,69217,62567,T,F,10.6,27929,26869,260.1933,266.0,74
+5915075,"Maple Ridge (B.C.)",DM ,F,68949,63169,F,F,9.2,26488,24935,265.7893,259.4,75
+1301006,"Saint John (N.B.)",CY ,F,68043,69661,F,F,-2.3,32090,29310,315.4919,215.7,76
+2449058,"Drummondville (Que.)",V  ,F,67392,63029,T,F,6.9,31087,29636,246.7928,273.1,77
+1307022,"Moncton (N.B.)",C  ,F,64128,61046,F,F,5.0,30093,27683,141.1697,454.3,78
+2475017,"Saint-Jérôme (Que.)",V  ,F,63729,59614,T,F,6.9,28724,27741,90.5036,704.2,79
+3528052,"Norfolk County (Ont.)",CY ,F,62563,60847,F,F,2.8,26527,24238,1606.9131,38.9,80
+5915029,"New Westminster (B.C.)",CY ,F,58549,54656,F,F,7.1,28670,27049,15.4087,3799.7,81
+4811062,"St. Albert (Alta.)",CY ,F,57719,53081,F,F,8.7,20938,20558,35.0357,1647.4,82
+3521024,"Caledon (Ont.)",T  ,F,57050,50605,T,F,12.7,18915,18214,687.1660,83.0,83
+4801006,"Medicine Hat (Alta.)",CY ,F,56997,51249,F,F,11.2,24729,23611,112.0097,508.9,84
+3524015,"Halton Hills (Ont.)",T  ,F,55289,48184,F,F,14.7,19265,18812,276.2616,200.1,85
+3548044,"North Bay (Ont.)",CY ,F,53966,52771,F,F,2.3,23841,22592,314.9081,171.4,86
+3524009,"Milton (Ont.)",T  ,F,53939,31471,F,F,71.4,18913,18448,366.6060,147.1,87
+5915039,"Port Coquitlam (B.C.)",CY ,F,52687,51257,F,F,2.8,19689,18709,28.8481,1826.4,88
+2436033,"Shawinigan (Que.)",V  ,F,51904,52040,T,F,-0.3,25835,24243,733.2733,70.8,89
+2454048,"Saint-Hyacinthe (Que.)",V  ,F,51616,50394,T,F,2.4,23956,22846,188.6861,273.6,90
+4816037,"Wood Buffalo (Alta.)",RGM,F,51496,41445,T,F,24.3,20505,17987,63342.8873,0.8,91
+1310032,"Fredericton (N.B.)",CY ,F,50535,47580,T,F,6.2,24632,22125,130.6757,386.7,92
+3526032,"Welland (Ont.)",CY ,F,50331,48402,F,F,4.0,21543,20717,81.0876,620.7,93
+2466142,"Dollard-Des Ormeaux (Que.)",V  ,F,48930,48206,T,F,1.5,17010,16352,15.1019,3240.0,94
+3512005,"Belleville (Ont.)",CY ,F,48821,46029,T,F,6.1,21239,20495,246.7610,197.8,95
+2447015,"Granby (Que.)",V  ,F,47637,44121,F,F,8.0,22418,21622,72.0473,661.2,96
+3519046,"Aurora (Ont.)",T  ,F,47629,40167,F,F,18.6,16032,15656,49.6192,959.9,97
+4819012,"Grande Prairie (Alta.)",CY ,F,47076,36983,F,F,27.3,17941,17326,61.0804,770.7,98
+2473015,"Blainville (Que.)",V  ,F,46493,36029,F,F,29.0,16399,16087,55.1022,843.8,99
+3501012,"Cornwall (Ont.)",CY ,F,45965,45640,F,F,0.7,20534,19704,61.5240,747.1,100
+3528018,"Haldimand County (Ont.)",CY ,F,45212,43728,F,F,3.4,18386,16308,1251.5768,36.1,101
+5915051,"North Vancouver (B.C.)",CY ,F,45165,44092,T,F,2.4,22643,21348,11.8475,3812.2,102
+3556027,"Timmins (Ont.)",CY ,F,42997,43686,F,F,-1.6,18642,17381,2961.5782,14.5,103
+2467050,"Châteauguay (Que.)",V  ,F,42786,41003,F,F,4.3,16594,16262,35.8922,1192.1,104
+3512015,"Quinte West (Ont.)",CY ,F,42697,41366,T,F,3.2,17612,16716,493.8509,86.5,105
+3519070,"Georgina (Ont.)",T  ,F,42346,39263,F,F,7.9,16879,15263,287.7157,147.2,106
+2410043,"Rimouski (Que.)",V  ,F,42240,41549,T,F,1.7,19699,18663,257.7912,163.9,107
+5915055,"West Vancouver (B.C.)",DM ,F,42131,41421,F,F,1.7,18057,16839,87.1289,483.5,108
+2472005,"Saint-Eustache (Que.)",V  ,F,42062,40378,F,F,4.2,17121,16692,69.4239,605.9,109
+4607062,"Brandon (Man.)",CY ,F,41511,39716,F,F,4.5,18662,17921,76.8872,539.9,110
+2439062,"Victoriaville (Que.)",V  ,F,40486,38841,F,F,4.2,17959,17390,84.2014,480.8,111
+2486042,"Rouyn-Noranda (Que.)",V  ,F,39924,39621,T,F,0.8,18921,17411,5991.0647,6.7,112
+2470052,"Salaberry-de-Valleyfield (Que.)",V  ,F,39672,39028,T,F,1.7,18034,17514,107.0981,370.4,113
+2458033,"Boucherville (Que.)",V  ,F,39062,36253,T,F,7.7,15179,14946,70.8078,551.7,114
+3534021,"St. Thomas (Ont.)",CY ,F,36110,33303,T,F,8.4,15225,14732,35.4812,1017.7,115
+5937014,"Vernon (B.C.)",CY ,F,35944,33542,T,F,7.2,16515,15685,94.2003,381.6,116
+3532042,"Woodstock (Ont.)",CY ,F,35480,33269,T,F,6.6,14960,14383,43.7888,810.3,117
+2474005,"Mirabel (Que.)",V  ,F,34626,27315,T,F,26.8,13161,12714,485.5081,71.3,118
+5909056,"Mission (B.C.)",DM ,F,34505,31272,F,F,10.3,12598,12182,225.7831,152.8,119
+3529005,"Brant (Ont.)",CY ,F,34415,31669,F,F,8.7,12517,12238,843.0989,40.8,120
+4806014,"Rocky View No. 44 (Alta.)",MD ,F,34171,29925,T,F,14.2,11604,11193,4014.8922,8.5,121
+4715066,"Prince Albert (Sask.)",CY ,F,34138,34291,F,F,-0.4,14029,13240,65.6825,519.7,122
+2453052,"Sorel-Tracy (Que.)",V  ,F,34076,34194,F,F,-0.3,15917,15301,58.0672,586.8,123
+2464015,"Mascouche (Que.)",V  ,F,33764,29556,F,F,14.2,12398,12059,106.6413,316.6,124
+3537064,"Lakeshore (Ont.)",T  ,F,33245,28746,F,F,15.7,12368,11630,530.3152,62.7,125
+1102075,"Charlottetown (P.E.I.)",CY ,F,32174,32245,F,F,-0.2,14995,13728,44.3298,725.8,126
+4707039,"Moose Jaw (Sask.)",CY ,F,32132,32131,F,F,0.0,14691,13685,46.8173,686.3,127
+5907041,"Penticton (B.C.)",CY ,F,31909,30985,F,F,3.0,15271,14594,42.0156,759.5,128
+2466058,"Côte-Saint-Luc (Que.)",V  ,F,31395,30244,T,F,3.8,14371,13534,6.9519,4516.0,129
+3543017,"Innisfil (Ont.)",T  ,F,31175,28666,F,F,8.8,12822,11402,284.1776,109.7,130
+2489008,"Val-d'Or (Que.)",V  ,F,31123,31430,T,F,-1.0,14073,13310,3545.2537,8.8,131
+3531011,"Stratford (Ont.)",CY ,F,30461,29780,T,F,2.3,13316,12875,25.2762,1205.1,132
+3543052,"Orillia (Ont.)",CY ,F,30259,29121,F,F,3.9,13013,12238,28.6060,1057.8,133
+2466097,"Pointe-Claire (Que.)",V  ,F,30161,29286,T,F,3.0,12608,12049,18.8779,1597.7,134
+2493042,"Alma (Que.)",V  ,F,29998,30126,T,F,-0.4,13336,12730,195.5871,153.4,135
+3526003,"Fort Erie (Ont.)",T  ,F,29925,28143,F,F,6.3,14251,12219,166.3529,179.9,136
+2429073,"Saint-Georges (Que.)",V  ,F,29616,28127,T,F,5.3,13476,12747,198.2103,149.4,137
+5925034,"Campbell River (B.C.)",CY ,F,29572,28276,T,F,4.6,12817,12226,143.4807,206.1,138
+4811034,"Parkland County (Alta.)",CM ,F,29265,27217,T,F,7.5,11064,10230,2392.6128,12.2,139
+2459010,"Sainte-Julie (Que.)",V  ,F,29079,26580,F,F,9.4,10503,10352,49.5264,587.1,140
+5935020,"Central Okanagan J (B.C.)",RDA,F,28972,26001,T,F,11.4,11967,10969,1297.8077,22.3,141
+4806021,"Airdrie (Alta.)",CY ,F,28927,20407,T,F,41.8,10768,10096,33.0981,874.0,142
+3537003,"Leamington (Ont.)",MU ,F,28833,27138,F,F,6.2,10465,9820,261.9243,110.1,143
+3543007,"New Tecumseth (Ont.)",T  ,F,27701,26141,F,F,6.0,10315,10039,274.1768,101.0,144
+3537034,"LaSalle (Ont.)",T  ,F,27652,25285,F,F,9.4,9537,9326,65.2512,423.8,145
+5919008,"North Cowichan (B.C.)",DM ,F,27557,26138,T,F,5.4,11584,11278,193.6583,142.3,146
+5915043,"Port Moody (B.C.)",CY ,F,27512,23816,F,F,15.5,10680,10127,25.6225,1073.7,147
+3522014,"Orangeville (Ont.)",T  ,F,26925,25248,F,F,6.6,9636,9429,15.5699,1729.3,148
+2473005,"Boisbriand (Que.)",V  ,F,26483,26744,T,F,-1.0,9818,9573,27.9374,947.9,149
+3523025,"Centre Wellington (Ont.)",TP ,F,26049,24260,F,F,7.4,10267,9543,407.3271,64.0,150
+2471083,"Vaudreuil-Dorion (Que.)",V  ,F,25789,19920,F,F,29.5,10637,10260,72.4984,355.7,151
+2431084,"Thetford Mines (Que.)",V  ,F,25704,26323,T,F,-2.4,12116,11565,226.8191,113.3,152
+2497007,"Sept-Îles (Que.)",V  ,F,25514,25392,T,F,0.5,11887,11006,1764.2622,14.5,153
+3513020,"Prince Edward (Ont.)",CY ,F,25496,24901,F,F,2.4,12055,10319,1050.1442,24.3,154
+2473010,"Sainte-Thérèse (Que.)",V  ,F,25224,24269,F,F,3.9,12202,11743,9.5814,2632.6,155
+1206001,"Lunenburg (N.S.)",MD ,F,25164,25570,F,F,-1.6,13237,10402,1759.1391,14.3,156
+1001542,"Mount Pearl (N.L.)",CY ,F,24671,24964,F,F,-1.2,9660,9195,15.7454,1566.9,157
+3519044,"Whitchurch-Stouffville (Ont.)",T  ,F,24390,22008,F,F,10.8,8898,8526,206.7391,118.0,158
+2458037,"Saint-Bruno-de-Montarville (Que.)",V  ,F,24388,23843,T,F,2.3,9391,9227,43.2750,563.6,159
+3537048,"Tecumseh (Ont.)",T  ,F,24224,24289,T,F,-0.3,8710,8496,94.7097,255.8,160
+3543014,"Bradford West Gwillimbury (Ont.)",T  ,F,24039,22228,F,F,8.1,8128,7946,201.0284,119.6,161
+2467035,"Saint-Constant (Que.)",V  ,F,23957,22577,F,F,6.1,8467,8352,57.2973,418.1,162
+3526065,"Grimsby (Ont.)",T  ,F,23937,21297,F,F,12.4,8944,8743,68.9447,347.2,163
+2445072,"Magog (Que.)",V  ,F,23880,22535,T,F,6.0,12553,10693,144.1170,165.7,164
+5915002,"Langley (B.C.)",CY ,F,23606,23643,F,F,-0.2,11110,10571,10.2230,2309.1,165
+2457005,"Chambly (Que.)",V  ,F,22608,20342,F,F,11.1,8740,8537,25.1142,900.2,166
+2496020,"Baie-Comeau (Que.)",V  ,F,22554,23079,F,F,-2.3,9931,9602,338.8823,66.6,167
+5917044,"Langford (B.C.)",CY ,F,22459,18840,F,F,19.2,9125,8650,39.5533,567.8,168
+1207001,"Kings, Subd. A (N.S.)",SC ,F,22161,22430,F,F,-1.2,10059,8643,1234.2156,18.0,169
+1001485,"Conception Bay South (N.L.)",T  ,F,21966,19772,F,F,11.1,8248,7906,59.2712,370.6,170
+3507015,"Brockville (Ont.)",CY ,F,21957,21375,F,F,2.7,10394,9998,20.7375,1058.8,171
+5925010,"Courtenay (B.C.)",CY ,F,21940,19166,T,F,14.5,10177,9748,26.6821,822.3,172
+2467015,"La Prairie (Que.)",V  ,F,21763,18896,F,F,15.2,8758,8557,43.2791,502.9,173
+3542059,"Owen Sound (Ont.)",CY ,F,21753,21456,T,F,1.4,9736,9381,24.2199,898.1,174
+3537028,"Amherstburg (Ont.)",T  ,F,21748,20339,F,F,6.9,8346,7927,185.6482,117.1,175
+3526057,"Lincoln (Ont.)",T  ,F,21722,20612,F,F,5.4,7875,7623,162.8588,133.4,176
+2458012,"Saint-Lambert (Que.)",V  ,F,21599,21051,T,F,2.6,10572,10222,7.5539,2859.3,177
+3518020,"Scugog (Ont.)",TP ,F,21439,20173,F,F,6.3,8345,7705,474.6299,45.2,178
+1208008,"East Hants (N.S.)",MD ,F,21387,20821,F,F,2.7,8753,8070,1787.6365,12.0,179
+3519054,"East Gwillimbury (Ont.)",T  ,F,21069,20555,F,F,2.5,7037,6887,245.0581,86.0,180
+2459020,"Varennes (Que.)",V  ,F,20950,19653,F,F,6.6,7711,7619,92.5323,226.4,181
+3537013,"Kingsville (Ont.)",T  ,F,20908,19619,F,F,6.6,7845,7456,246.8398,84.7,182
+3502036,"Clarence-Rockland (Ont.)",CY ,F,20790,19612,F,F,6.0,7667,7491,296.5321,70.1,183
+2466032,"Westmount (Que.)",V  ,F,20494,19727,T,F,3.9,9418,8677,4.0243,5092.6,184
+2466102,"Kirkland (Que.)",V  ,F,20491,20434,T,F,0.3,6700,6538,9.6412,2125.4,185
+6001009,"Whitehorse (Y.T.)",CY ,F,20461,19058,F,F,7.4,8631,8280,416.4341,49.1,186
+1005018,"Corner Brook (N.L.)",CY ,F,20083,20103,F,F,-0.1,8483,8092,148.2650,135.5,187
+3537016,"Essex (Ont.)",T  ,F,20032,20085,F,F,-0.3,8377,7642,277.9472,72.1,188
+3543023,"Oro-Medonte (Ont.)",TP ,F,20031,18315,F,F,9.4,8382,7322,586.6499,34.1,189
+3539015,"Strathroy-Caradoc (Ont.)",TP ,F,19977,19154,T,F,4.3,7675,7495,274.1851,72.9,190
+4806001,"Foothills No. 31 (Alta.)",MD ,F,19736,16602,T,F,18.9,7460,6954,3643.5968,5.4,191
+3530035,"Woolwich (Ont.)",TP ,F,19658,18201,F,F,8.0,6805,6582,325.9984,60.3,192
+4811049,"Spruce Grove (Alta.)",CY ,F,19496,15983,F,F,22.0,7293,7068,26.4038,738.4,193
+3519049,"King (Ont.)",TP ,F,19487,18533,F,F,5.1,6576,6398,333.0384,58.5,194
+1210008,"Colchester, Subd. B (N.S.)",SC ,F,19297,18607,F,F,3.7,8545,7750,1248.2149,15.5,195
+2466107,"Beaconsfield (Que.)",V  ,F,19194,19310,T,F,-0.6,6749,6558,11.0102,1743.3,196
+3518029,"Uxbridge (Ont.)",TP ,F,19169,17377,F,F,10.3,6916,6658,420.6530,45.6,197
+4808001,"Red Deer County (Alta.)",CM ,F,19108,18492,T,F,3.3,8014,6684,4002.5779,4.8,198
+2461025,"Joliette (Que.)",V  ,F,19044,17837,F,F,6.8,9092,8811,22.8072,835.0,199
+2466072,"Mont-Royal (Que.)",V  ,F,18933,18682,T,F,1.3,7377,7021,7.6622,2471.0,200
+2457040,"Beloeil (Que.)",V  ,F,18927,19053,F,F,-0.7,7626,7461,24.0879,785.7,201
+5915007,"White Rock (B.C.)",CY ,F,18755,18250,T,F,2.8,10192,9526,5.1622,3633.1,202
+6106023,"Yellowknife (N.W.T.)",CY ,F,18700,16541,F,F,13.1,7159,6616,105.2205,177.7,203
+4811059,"Sturgeon County (Alta.)",MD ,F,18621,18067,F,F,3.1,6302,6037,2108.9028,8.8,204
+3526011,"Port Colborne (Ont.)",CY ,F,18599,18450,F,F,0.8,8519,7791,121.9683,152.5,205
+2412072,"Rivière-du-Loup (Que.)",V  ,F,18586,17772,F,F,4.6,8676,8227,84.2291,220.7,206
+1307045,"Dieppe (N.B.)",C  ,F,18565,14951,F,F,24.2,7495,7148,51.1749,362.8,207
+3544042,"Huntsville (Ont.)",T  ,F,18280,17338,F,F,5.4,9691,7190,703.2257,26.0,208
+5901022,"Cranbrook (B.C.)",CY ,F,18267,18517,T,F,-1.4,7876,7634,25.1440,726.5,209
+3510020,"South Frontenac (Ont.)",TP ,F,18227,16415,F,F,11.0,9069,6766,941.2848,19.4,210
+3526037,"Thorold (Ont.)",CY ,F,18224,18048,F,F,1.0,7678,7054,83.0013,219.6,211
+3514021,"Cobourg (Ont.)",T  ,F,18210,17172,F,F,6.0,7571,7299,22.3716,814.0,212
+1309050,"Miramichi (N.B.)",C  ,F,18129,18508,F,F,-2.0,7930,7342,179.8377,100.8,213
+2466087,"Dorval (Que.)",CÉ ,F,18088,17706,T,F,2.2,8118,7811,20.8749,866.5,214
+4819006,"Grande Prairie County No. 1 (Alta.)",CM ,F,17970,15638,F,F,14.9,6460,6234,5883.9161,3.1,215
+5917030,"Oak Bay (B.C.)",DM ,F,17908,17798,F,F,0.6,8280,7898,10.3835,1724.7,216
+1306020,"Riverview (N.B.)",T  ,F,17832,17010,F,F,4.8,7119,6893,33.8802,526.3,217
+5923008,"Port Alberni (B.C.)",CY ,F,17548,17748,T,F,-1.1,8061,7652,19.9176,881.0,218
+3543009,"Springwater (Ont.)",TP ,F,17456,16104,F,F,8.4,6361,5942,536.3023,32.5,219
+3515015,"Smith-Ennismore-Lakefield (Ont.)",TP ,F,17413,16414,F,F,6.1,8988,6730,318.7667,54.6,220
+2472010,"Deux-Montagnes (Que.)",V  ,F,17402,17080,F,F,1.9,6910,6781,6.1583,2825.8,221
+5955034,"Fort St. John (B.C.)",CY ,F,17402,16051,T,F,8.4,7129,6874,22.7360,765.4,221
+3543031,"Collingwood (Ont.)",T  ,F,17290,16039,F,F,7.8,9316,7318,33.4561,516.8,223
+2423072,"Saint-Augustin-de-Desmaures (Que.)",V  ,F,17281,15732,T,F,9.8,6111,5969,85.7590,201.5,224
+4806012,"Okotoks (Alta.)",T  ,F,17145,11689,T,F,46.7,5927,5759,18.5480,924.4,225
+3530020,"Wilmot (Ont.)",TP ,F,17097,14866,F,F,15.0,6296,6094,263.7324,64.8,226
+2471105,"Saint-Lazare (Que.)",V  ,F,17016,12895,F,F,32.0,5765,5679,66.5343,255.7,227
+4811016,"Leduc (Alta.)",CY ,F,16967,15032,F,F,12.9,6718,6528,36.9693,458.9,228
+3543021,"Essa (Ont.)",TP ,F,16901,16808,F,F,0.6,6212,5683,279.5660,60.5,229
+5917040,"Esquimalt (B.C.)",DM ,F,16840,16127,F,F,4.4,8340,8007,7.0429,2391.1,230
+2460028,"L'Assomption (Que.)",V  ,F,16738,15625,T,F,7.1,6526,6382,100.7847,166.1,231
+1313027,"Edmundston (N.B.)",CY ,F,16643,17373,F,F,-4.2,7804,7361,106.9248,155.7,232
+2423057,"L'Ancienne-Lorette (Que.)",V  ,F,16516,15929,T,F,3.7,6818,6727,7.6332,2163.7,233
+3514020,"Port Hope (Ont.)",MU ,F,16390,15605,F,F,5.0,6560,6287,278.9727,58.8,234
+3543074,"Midland (Ont.)",T  ,F,16300,16214,F,F,0.5,7248,6897,29.0894,560.3,235
+2467030,"Sainte-Catherine (Que.)",V  ,F,16211,15953,F,F,1.6,6170,6065,9.5018,1706.1,236
+3526028,"Pelham (Ont.)",T  ,F,16155,15272,F,F,5.8,6058,5933,126.4169,127.8,237
+5939032,"Salmon Arm (B.C.)",CY ,F,16012,15210,F,F,5.3,6855,6541,155.3637,103.1,238
+2467020,"Candiac (Que.)",V  ,F,15947,12675,F,F,25.8,6115,5967,17.4213,915.4,239
+4810039,"Lloydminster (Part) (Alta.)",CY ,F,15910,13148,F,F,21.0,6346,6079,24.1860,657.8,240
+5917015,"Central Saanich (B.C.)",DM ,F,15745,15348,F,F,2.6,6493,6241,41.4199,380.1,241
+2457035,"Mont-Saint-Hilaire (Que.)",V  ,F,15720,14270,F,F,10.2,6325,6164,44.2913,354.9,242
+3544018,"Bracebridge (Ont.)",T  ,F,15652,13751,F,F,13.8,8568,6231,617.4155,25.4,243
+5915070,"Pitt Meadows (B.C.)",DM ,F,15623,14670,F,F,6.5,6149,5821,85.3781,183.0,244
+4810011,"Camrose (Alta.)",CY ,F,15620,14870,T,F,5.0,6962,6725,31.1388,501.6,245
+2457020,"Saint-Basile-le-Grand (Que.)",V  ,F,15605,12385,F,F,26.0,5816,5734,36.1013,432.3,246
+3539033,"Middlesex Centre (Ont.)",TP ,F,15589,14242,F,F,9.5,5346,5235,588.0519,26.5,247
+3511015,"Greater Napanee (Ont.)",T  ,F,15400,15132,F,F,1.8,6695,6118,459.7060,33.5,248
+1305057,"Quispamsis (N.B.)",TV ,F,15239,13757,F,F,10.8,5324,5197,57.0582,267.1,249
+3560010,"Kenora (Ont.)",CY ,F,15177,15838,F,F,-4.2,6845,6251,210.9057,72.0,250
+3511005,"Loyalist (Ont.)",TP ,F,15062,14590,F,F,3.2,5814,5566,340.0235,44.3,251
+4709012,"Yorkton (Sask.)",CY ,F,15038,15107,F,F,-0.5,6903,6543,24.5653,612.2,252
+3543064,"Wasaga Beach (Ont.)",T  ,F,15029,12419,F,F,21.0,9716,6236,58.4281,257.2,253
+4811056,"Fort Saskatchewan (Alta.)",CY ,F,14957,13121,F,F,14.0,5825,5664,48.1249,310.8,254
+5931006,"Squamish (B.C.)",DM ,F,14949,14247,F,F,4.9,6011,5614,106.1123,140.9,255
+4708004,"Swift Current (Sask.)",CY ,F,14946,14821,F,F,0.8,6957,6649,24.0385,621.8,256
+3532004,"Tillsonburg (Ont.)",T  ,F,14822,14052,F,F,5.5,6519,6374,22.3352,663.6,257
+2403005,"Gaspé (Que.)",V  ,F,14819,14932,F,F,-0.8,6410,5964,1120.6193,13.2,258
+2408053,"Matane (Que.)",V  ,F,14742,14948,T,F,-1.4,7073,6743,195.4747,75.4,259
+5917041,"Colwood (B.C.)",CY ,F,14687,13745,F,F,6.9,5770,5501,17.7628,826.8,260
+3547076,"Petawawa (Ont.)",T  ,F,14651,14398,F,F,1.8,5849,5329,164.6784,89.0,261
+3538003,"St. Clair (Ont.)",TP ,F,14649,14659,F,F,-0.1,5913,5591,619.2999,23.7,262
+3526047,"Niagara-on-the-Lake (Ont.)",T  ,F,14587,13839,F,F,5.4,6025,5447,132.8288,109.8,263
+2492022,"Dolbeau-Mistassini (Que.)",V  ,F,14546,14879,F,F,-2.2,6838,6367,295.6730,49.2,264
+1103025,"Summerside (P.E.I.)",CY ,F,14500,14654,F,F,-1.1,6298,5928,28.3612,511.3,265
+3507065,"North Grenville (Ont.)",MU ,F,14198,13581,F,F,4.5,5513,5242,350.1382,40.5,266
+2473020,"Rosemère (Que.)",V  ,F,14173,13391,F,F,5.8,5001,4872,10.7723,1315.7,267
+2463048,"Saint-Lin--Laurentides (Que.)",V  ,F,14159,12379,T,F,14.4,5725,5350,118.5168,119.5,268
+3543005,"Clearview (Ont.)",TP ,F,14088,13796,F,F,2.1,5814,5011,557.3192,25.3,269
+3547064,"Pembroke (Ont.)",CY ,F,13930,13490,F,F,3.3,6351,6012,14.3505,970.7,270
+3502048,"Russell (Ont.)",TP ,F,13883,12412,F,F,11.9,4838,4730,198.9560,69.8,271
+1208001,"West Hants (N.S.)",MD ,F,13881,13780,F,F,0.7,6101,5462,1238.1236,11.2,272
+4806019,"Cochrane (Alta.)",T  ,F,13760,12041,T,F,14.3,4969,4837,30.0267,458.3,273
+1006017,"Grand Falls-Windsor (N.L.)",T  ,F,13558,13340,F,F,1.6,5564,5314,54.4795,248.9,274
+4622026,"Thompson (Man.)",CY ,F,13446,13256,F,F,1.4,5129,4811,17.1772,782.8,275
+3548055,"West Nipissing / Nipissing Ouest (Ont.)",M  ,F,13410,13114,T,F,2.3,6554,5574,1989.5663,6.7,276
+2479088,"Mont-Laurier (Que.)",V  ,F,13405,12766,T,F,5.0,6480,5646,590.3519,22.7,277
+1210001,"Colchester, Subd. C (N.S.)",SC ,F,13312,13391,F,F,-0.6,5639,5223,1443.0503,9.2,278
+4716029,"North Battleford (Sask.)",CY ,F,13190,13692,F,F,-3.7,5943,5520,33.5475,393.2,279
+3526021,"West Lincoln (Ont.)",TP ,F,13167,12268,F,F,7.3,4433,4296,387.7207,34.0,280
+3539027,"Thames Centre (Ont.)",MU ,F,13085,12473,F,F,4.9,4695,4587,433.8043,30.2,281
+2473035,"Sainte-Anne-des-Plaines (Que.)",V  ,F,13001,12908,F,F,0.7,4629,4516,92.7894,140.1,282
+4612047,"Springfield (Man.)",RM ,F,12990,12602,F,F,3.1,4601,4490,1100.8061,11.8,283
+5927008,"Powell River (B.C.)",CY ,F,12957,12983,F,F,-0.2,5936,5689,29.7687,435.3,284
+3501005,"South Glengarry (Ont.)",TP ,F,12880,12700,F,F,1.4,5277,4945,604.9141,21.3,285
+5947012,"Prince Rupert (B.C.)",CY ,F,12815,14643,F,F,-12.5,5954,5068,54.8989,233.4,286
+4811012,"Leduc County (Alta.)",CM ,F,12730,12528,F,F,1.6,4915,4581,2610.2504,4.9,287
+4609029,"Portage la Prairie (Man.)",CY ,F,12728,12976,F,F,-1.9,5498,5212,24.6737,515.9,288
+3534020,"Central Elgin (Ont.)",MU ,F,12723,12293,T,F,3.5,5115,4778,280.2212,45.4,289
+1315011,"Bathurst (N.B.)",CY ,F,12714,12924,F,F,-1.6,6158,5567,91.5469,138.9,290
+1001517,"Paradise (N.L.)",T  ,F,12584,9598,F,F,31.1,4734,4493,29.2370,430.4,291
+2488055,"Amos (Que.)",V  ,F,12584,13044,F,F,-3.5,5530,5339,430.0604,29.3,291
+2401023,"Les Îles-de-la-Madeleine (Que.)",MÉ ,F,12560,12281,T,F,2.3,5607,4969,168.1117,74.7,293
+3501011,"South Stormont (Ont.)",TP ,F,12520,11941,F,F,4.8,4763,4636,447.4593,28.0,294
+4802034,"Brooks (Alta.)",CY ,F,12498,11604,F,F,7.7,5051,4833,17.7015,706.0,295
+4806028,"Mountain View County (Alta.)",CM ,F,12391,12124,T,F,2.2,5136,4659,3804.4326,3.3,296
+4811048,"Stony Plain (Alta.)",T  ,F,12363,9624,T,F,28.5,4808,4613,35.6067,347.2,297
+3531040,"North Perth (Ont.)",MU ,F,12254,12055,F,F,1.7,4832,4615,493.1831,24.8,298
+3514045,"Trent Hills (Ont.)",MU ,F,12247,12569,F,F,-2.6,6468,5141,510.8274,24.0,299
+3542004,"West Grey (Ont.)",MU ,F,12193,11741,F,F,3.8,5265,4719,875.3679,13.9,300
+2446080,"Cowansville (Que.)",V  ,F,12182,12032,F,F,1.2,5461,5155,46.0904,264.3,301
+5925005,"Comox (B.C.)",T  ,F,12136,11391,T,F,6.5,5463,5201,15.1607,800.5,302
+2452007,"Lavaltrie (Que.)",V  ,F,12120,11163,T,F,8.6,4555,4432,68.1811,177.8,303
+3523009,"Guelph/Eramosa (Ont.)",TP ,F,12066,11174,F,F,8.0,4161,4069,291.7341,41.4,304
+3531030,"Perth East (Ont.)",TP ,F,12041,12119,T,F,-0.6,4004,3885,715.0662,16.8,305
+4815023,"Canmore (Alta.)",T  ,F,12039,10792,F,F,11.6,6575,4778,68.8954,174.7,306
+1207016,"Kings, Subd. B (N.S.)",SC ,F,12033,11619,F,F,3.6,5132,4726,346.1739,34.8,307
+2461035,"Saint-Charles-Borromée (Que.)",MÉ ,F,12030,10668,F,F,12.8,5349,5192,18.6315,645.7,308
+3543015,"Severn (Ont.)",TP ,F,12030,11135,F,F,8.0,6491,4628,534.7802,22.5,308
+4812002,"Cold Lake (Alta.)",CY ,F,11991,11520,F,F,4.1,4834,4314,59.2999,202.2,310
+3518039,"Brock (Ont.)",TP ,F,11979,12110,F,F,-1.1,4927,4422,423.3067,28.3,311
+2470022,"Beauharnois (Que.)",V  ,F,11918,11464,T,F,4.0,5257,5116,69.0870,172.5,312
+4602041,"Hanover (Man.)",RM ,F,11871,10789,F,F,10.0,3478,3370,740.3116,16.0,313
+2476020,"Lachute (Que.)",V  ,F,11832,11628,F,F,1.8,5449,5215,108.6713,108.9,314
+4809002,"Clearwater County (Alta.)",MD ,F,11826,11505,F,F,2.8,4891,4448,18691.6529,0.6,315
+2490012,"La Tuque (Que.)",V  ,F,11821,12488,T,F,-5.3,6438,5338,25104.5904,0.5,316
+1210006,"Truro (N.S.)",T  ,F,11765,11457,F,F,2.7,5876,5557,37.6256,312.7,317
+3532018,"Ingersoll (Ont.)",T  ,F,11760,10977,F,F,7.1,4670,4572,12.8959,911.9,318
+2447020,"Granby (Que.)",CT ,F,11748,11335,F,F,3.6,4129,4071,80.6749,145.6,319
+3509030,"Mississippi Mills (Ont.)",T  ,F,11734,11647,F,F,0.7,4581,4375,509.0486,23.1,320
+3541045,"Saugeen Shores (Ont.)",T  ,F,11720,11388,F,F,2.9,6645,4926,170.5828,68.7,321
+4811002,"Wetaskiwin (Alta.)",CY ,F,11673,11154,F,F,4.7,4956,4765,16.7361,697.5,322
+1305045,"Rothesay (N.B.)",TV ,F,11637,11505,F,F,1.1,4536,4317,34.7345,335.0,323
+2426030,"Sainte-Marie (Que.)",V  ,F,11584,11320,F,F,2.3,4826,4679,107.1674,108.1,324
+3557041,"Elliot Lake (Ont.)",CY ,F,11549,11956,F,F,-3.4,6061,5647,698.1178,16.5,325
+4613043,"St. Andrews (Man.)",RM ,F,11359,10695,F,F,6.2,4389,4023,752.7044,15.1,326
+2418050,"Montmagny (Que.)",V  ,F,11353,11654,F,F,-2.6,5404,5029,126.0715,90.1,327
+5949011,"Terrace (B.C.)",CY ,F,11320,12109,F,F,-6.5,4682,4321,41.5183,272.7,328
+5917010,"Sidney (B.C.)",T  ,F,11315,10929,F,F,3.5,5498,5209,5.0427,2243.8,329
+2472015,"Sainte-Marthe-sur-le-Lac (Que.)",V  ,F,11311,8742,F,F,29.4,4461,4276,9.3141,1214.4,330
+2471070,"Pincourt (Que.)",V  ,F,11197,10107,F,F,10.8,4277,4098,7.5426,1484.5,331
+1204010,"Queens (N.S.)",RGM,F,11177,11665,T,F,-4.2,6150,4700,2386.5757,4.7,332
+3523050,"Wellington North (Ont.)",TP ,F,11175,11305,F,F,-1.1,4538,4238,524.3775,21.3,333
+3541024,"Kincardine (Ont.)",MU ,F,11173,11029,F,F,1.3,5447,4586,537.6510,20.8,334
+3538040,"Lambton Shores (Ont.)",MU ,F,11150,10571,F,F,5.5,6773,4790,331.0810,33.7,335
+3523017,"Erin (Ont.)",T  ,F,11148,11052,F,F,0.9,3960,3808,296.9784,37.5,336
+2438010,"Bécancour (Que.)",V  ,F,11134,11051,F,F,0.8,4887,4608,441.0031,25.2,337
+3501030,"North Dundas (Ont.)",TP ,F,11095,11014,F,F,0.7,4323,4175,503.1755,22.0,338
+4602044,"Steinbach (Man.)",CY ,F,11066,9227,F,F,19.9,4377,4248,25.5695,432.8,339
+5915020,"Greater Vancouver A (B.C.)",RDA,F,11050,8034,F,F,37.5,6011,4500,818.6183,13.5,340
+3544002,"Gravenhurst (Ont.)",T  ,F,11046,10899,F,F,1.3,8235,4425,517.9924,21.3,341
+5955014,"Dawson Creek (B.C.)",CY ,F,10994,10754,F,F,2.2,4833,4651,22.3237,492.5,342
+5921018,"Parksville (B.C.)",CY ,F,10993,10323,F,F,6.5,5469,5204,14.6038,752.7,343
+3514019,"Hamilton (Ont.)",TP ,F,10972,10785,F,F,1.7,4499,3994,256.1075,42.8,344
+3542047,"Meaford (Ont.)",MU ,F,10948,10381,F,F,5.5,5193,4442,588.4668,18.6,345
+3502008,"Hawkesbury (Ont.)",T  ,F,10869,10319,T,F,5.3,4974,4734,9.4574,1149.3,346
+5907035,"Summerland (B.C.)",DM ,F,10828,10723,T,F,1.0,4726,4527,73.8774,146.6,347
+5917005,"North Saanich (B.C.)",DM ,F,10823,10436,F,F,3.7,4500,4278,37.1448,291.4,348
+3543068,"Tiny (Ont.)",TP ,F,10784,9035,F,F,19.4,9072,4337,343.1860,31.4,349
+5941009,"Williams Lake (B.C.)",CY ,F,10744,11153,F,F,-3.7,4711,4455,33.1146,324.4,350
+4808031,"Lacombe (Alta.)",T  ,F,10742,9384,F,F,14.5,4037,3904,18.2439,588.8,351
+1206009,"Chester (N.S.)",MD ,F,10741,10781,F,F,-0.4,6161,4644,1120.7515,9.6,352
+3554020,"Temiskaming Shores (Ont.)",CY ,F,10732,10630,T,F,1.0,4833,4498,176.9964,60.6,353
+4806006,"High River (Alta.)",T  ,F,10716,9383,T,F,14.2,4363,4196,14.2689,751.0,354
+3543003,"Adjala-Tosorontio (Ont.)",TP ,F,10695,10082,F,F,6.1,3702,3540,372.3330,28.7,355
+3502025,"The Nation / La Nation (Ont.)",M  ,F,10643,10599,F,F,0.4,3893,3733,657.1634,16.2,356
+3501050,"North Glengarry (Ont.)",TP ,F,10635,10589,F,F,0.4,4553,4255,642.4042,16.6,357
+2477022,"Sainte-Adèle (Que.)",V  ,F,10634,9215,F,F,15.4,6397,4986,119.9836,88.6,358
+2491025,"Roberval (Que.)",V  ,F,10544,10906,F,F,-3.3,4844,4501,152.9928,68.9,359
+3501020,"South Dundas (Ont.)",TP ,F,10535,10783,F,F,-2.3,4322,4157,519.9777,20.3,360
+4811001,"Wetaskiwin County No. 10 (Alta.)",CM ,F,10535,10695,F,F,-1.5,4561,3939,3130.8974,3.4,360
+3542053,"Georgian Bluffs (Ont.)",TP ,F,10506,10127,T,F,3.7,4697,4027,603.5772,17.4,362
+3532002,"Norwich (Ont.)",TP ,F,10481,10478,F,F,0.0,3555,3469,431.2767,24.3,363
+2491042,"Saint-Félicien (Que.)",V  ,F,10477,10622,F,F,-1.4,4884,4411,363.5654,28.8,364
+4808022,"Lacombe County (Alta.)",CM ,F,10451,10572,T,F,-1.1,4008,3642,2777.2633,3.8,365
+2475028,"Sainte-Sophie (Que.)",MÉ ,F,10355,8966,F,F,15.5,4142,3923,111.2762,93.1,366
+3507040,"Rideau Lakes (Ont.)",TP ,F,10350,9687,F,F,6.8,6468,4167,710.2451,14.6,367
+1202004,"Yarmouth (N.S.)",MD ,F,10304,10466,T,F,-1.5,4906,4082,585.2748,17.6,368
+4802011,"Lethbridge County (Alta.)",CM ,F,10302,9935,T,F,3.7,2986,2884,2839.2818,3.6,369
+3514004,"Brighton (Ont.)",MU ,F,10253,9449,F,F,8.5,4328,3965,222.5218,46.1,370
+4805018,"Strathmore (Alta.)",T  ,F,10225,7621,F,F,34.2,3943,3778,15.5934,655.7,371
+4808012,"Sylvan Lake (Alta.)",T  ,F,10208,7503,T,F,36.1,4277,3667,10.8329,942.3,372
+3507014,"Elizabethtown-Kitley (Ont.)",TP ,F,10201,10039,F,F,1.6,3818,3603,554.2351,18.4,373
+4812004,"Bonnyville No. 87 (Alta.)",MD ,F,10194,9473,F,F,7.6,3849,3505,6057.4416,1.7,374
+2475005,"Saint-Colomban (Que.)",PE ,F,10136,7520,F,F,34.8,3966,3807,93.5234,108.4,375
+2475040,"Prévost (Que.)",V  ,F,10132,8280,F,F,22.4,4109,3856,35.0286,289.2,376
+2467045,"Mercier (Que.)",V  ,F,10121,9442,F,F,7.2,3733,3654,45.9521,220.3,377
+4701024,"Estevan (Sask.)",CY ,F,10084,10242,F,F,-1.5,4455,4238,17.5556,574.4,378
+2462037,"Rawdon (Que.)",MÉ ,F,10058,8648,F,F,16.3,5191,4261,186.9516,53.8,379
+4814003,"Yellowhead County (Alta.)",MD ,F,10045,9881,F,F,1.7,4177,3799,22303.8208,0.5,380
+4817095,"Mackenzie No. 23 (Alta.)",MD ,F,10002,8829,F,F,13.3,2892,2687,80484.4230,0.1,381
+3540005,"South Huron (Ont.)",MU ,F,9982,10019,F,F,-0.4,4427,4059,425.3494,23.5,382
+1006009,"Gander (N.L.)",T  ,F,9951,9651,F,F,3.1,4153,3869,104.2527,95.5,383
+2471060,"L'Île-Perrot (Que.)",V  ,F,9927,9375,F,F,5.9,4371,4218,5.5581,1786.0,384
+2471065,"Notre-Dame-de-l'Île-Perrot (Que.)",V  ,F,9885,8546,F,F,15.7,3459,3361,27.7954,355.6,385
+3523033,"Mapleton (Ont.)",TP ,F,9851,9303,F,F,5.9,3297,2892,534.7122,18.4,386
+3530027,"Wellesley (Ont.)",TP ,F,9789,9365,F,F,4.5,2913,2839,277.8411,35.2,387
+3543071,"Tay (Ont.)",TP ,F,9748,9162,F,F,6.4,5022,3837,138.9296,70.2,388
+4814019,"Hinton (Alta.)",T  ,F,9738,9405,F,F,3.5,3913,3676,25.7586,378.0,389
+4613056,"St. Clements (Man.)",RM ,F,9706,9115,F,F,6.5,4954,3671,728.6686,13.3,390
+5917052,"Sooke (B.C.)",DM ,F,9704,8735,F,F,11.1,4122,3859,50.0139,194.0,391
+2478032,"Sainte-Agathe-des-Monts (Que.)",V  ,F,9679,8687,T,F,,5642,4271,128.3759,75.4,392
+3541032,"Brockton (Ont.)",MU ,F,9641,9658,F,F,-0.2,4064,3739,565.0713,17.1,393
+5917027,"Capital F (B.C.)",RDA,F,9640,9279,F,F,3.9,5131,4319,182.2281,52.9,394
+2473025,"Lorraine (Que.)",V  ,F,9613,9476,F,F,1.4,3250,3211,6.0378,1592.1,395
+5935016,"Lake Country (B.C.)",DM ,F,9606,9267,F,F,3.7,3988,3644,122.1582,78.6,396
+4806017,"Chestermere (Alta.)",T  ,F,9564,3856,T,F,148.0,3165,3066,8.9098,1073.4,397
+2482015,"Val-des-Monts (Que.)",MÉ ,F,9539,7842,F,F,21.6,5537,3673,435.5671,21.9,398
+4813001,"Lac Ste. Anne County (Alta.)",MD ,F,9516,8948,F,F,6.3,4567,3673,2842.4603,3.3,399
+4613047,"Selkirk (Man.)",CY ,F,9515,9752,F,F,-2.4,3955,3837,24.8729,382.5,400
+1211011,"Amherst (N.S.)",T  ,F,9505,9470,F,F,0.4,4410,4152,12.0205,790.7,401
+3542015,"Grey Highlands (Ont.)",MU ,F,9480,9196,F,F,3.1,5142,3687,880.5990,10.8,402
+5937010,"Coldstream (B.C.)",DM ,F,9471,9106,F,F,4.0,3565,3423,67.2530,140.8,403
+1212014,"New Glasgow (N.S.)",T  ,F,9455,9432,F,F,0.2,4343,4162,9.9258,952.6,404
+3509028,"Carleton Place (Ont.)",T  ,F,9453,9083,F,F,4.1,3832,3702,8.8342,1070.0,405
+3507021,"Leeds and the Thousand Islands (Ont.)",TP ,F,9435,9069,F,F,4.0,5306,3649,607.1826,15.5,406
+4702047,"Weyburn (Sask.)",CY ,F,9433,9534,F,F,-1.1,4267,4046,15.7831,597.7,407
+3543019,"Ramara (Ont.)",TP ,F,9427,8615,F,F,9.4,5797,3784,417.2506,22.6,408
+3543072,"Penetanguishene (Ont.)",T  ,F,9354,8316,F,F,12.5,3685,3489,25.3752,368.6,409
+5941013,"Quesnel (B.C.)",CY ,F,9326,10044,F,F,-7.1,4443,3917,35.3445,263.9,410
+3540040,"Huron East (Ont.)",MU ,F,9310,9680,F,F,-3.8,3645,3432,669.1644,13.9,411
+2434128,"Saint-Raymond (Que.)",V  ,F,9273,8836,F,F,4.9,5035,3970,670.5461,13.8,412
+3547075,"Laurentian Valley (Ont.)",TP ,F,9265,8733,F,F,6.1,3506,3397,552.4412,16.8,413
+5903015,"Nelson (B.C.)",CY ,F,9258,9318,T,F,-0.6,4427,4160,11.7245,789.6,414
+5931020,"Whistler (B.C.)",DM ,F,9248,8896,F,F,4.0,8751,3909,161.7067,57.2,415
+2444037,"Coaticook (Que.)",V  ,F,9204,8988,F,F,2.4,3978,3733,218.5507,42.1,416
+2477043,"Saint-Sauveur (Que.)",V  ,F,9191,8122,T,F,13.2,5890,4356,47.7085,192.6,417
+4603050,"Winkler (Man.)",CY ,F,9106,7943,F,F,14.6,3371,3282,17.0133,535.2,418
+4602069,"Taché (Man.)",RM ,F,9083,8578,F,F,5.9,2972,2899,581.5154,15.6,419
+3530004,"North Dumfries (Ont.)",TP ,F,9063,8769,F,F,3.4,3103,3050,187.2169,48.4,420
+1212011,"Pictou, Subd. C (N.S.)",SC ,F,9038,9181,F,F,-1.6,4533,3700,1255.3518,7.2,421
+5949005,"Kitimat (B.C.)",DM ,F,8987,10285,F,F,-12.6,4256,3627,242.6283,37.0,422
+4813030,"Whitecourt (Alta.)",T  ,F,8971,8334,F,F,7.6,3448,3285,26.1436,343.1,423
+4811013,"Beaumont (Alta.)",T  ,F,8961,7006,F,F,27.9,2858,2792,10.5029,853.2,424
+2415013,"La Malbaie (Que.)",V  ,F,8959,9143,F,F,-2.0,4182,3721,459.3427,19.5,425
+2478102,"Mont-Tremblant (Que.)",V  ,F,8892,8317,T,F,6.9,6628,3873,234.4025,37.9,426
+1307019,"Moncton (N.B.)",P  ,F,8861,8743,F,F,1.3,3466,3324,582.2002,15.2,427
+3531025,"West Perth (Ont.)",MU ,F,8839,9129,F,F,-3.2,3341,3141,579.3976,15.3,428
+3515013,"Cavan-Millbrook-North Monaghan (Ont.)",TP ,F,8828,8453,F,F,4.4,3088,3018,306.1253,28.8,429
+3534010,"Malahide (Ont.)",TP ,F,8828,8777,T,F,0.6,2889,2726,395.0705,22.3,429
+1203001,"Clare (N.S.)",MD ,F,8813,9067,F,F,-2.8,4558,3699,852.8229,10.3,431
+3509004,"Smiths Falls (Ont.)",T  ,F,8777,9140,F,F,-4.0,4106,3812,8.1972,1070.7,432
+5917047,"View Royal (B.C.)",T  ,F,8768,7271,F,F,20.6,3512,3350,14.4837,605.4,433
+4613032,"East St. Paul (Man.)",RM ,F,8733,7677,F,F,13.8,2944,2907,42.0975,207.4,434
+3502010,"Champlain (Ont.)",TP ,F,8683,8586,T,F,1.1,3649,3447,207.1522,41.9,435
+1202001,"Argyle (N.S.)",MD ,F,8656,8698,T,F,-0.5,3912,3375,1527.1024,5.7,436
+3502023,"Alfred and Plantagenet (Ont.)",TP ,F,8654,8593,F,F,0.7,3581,3373,391.6799,22.1,437
+4808038,"Ponoka County (Alta.)",CM ,F,8640,8791,T,F,-1.7,3330,3033,2807.9369,3.1,438
+3556066,"Kapuskasing (Ont.)",T  ,F,8509,9238,F,F,-7.9,4022,3741,83.9842,101.3,439
+3523043,"Minto (Ont.)",T  ,F,8504,8164,F,F,4.2,3276,3135,300.3738,28.3,440
+5921023,"Qualicum Beach (B.C.)",T  ,F,8502,7849,T,F,8.3,4217,4002,17.9984,472.4,441
+2457030,"Otterburn Park (Que.)",V  ,F,8464,7866,F,F,7.6,3140,3090,5.3462,1583.2,442
+5929011,"Sechelt (B.C.)",DM ,F,8454,7775,F,F,8.7,4272,3853,39.7068,212.9,443
+3541055,"South Bruce Peninsula (Ont.)",T  ,F,8415,8090,F,F,4.0,6759,3581,531.8953,15.8,444
+1303012,"Oromocto (N.B.)",T  ,F,8402,8843,F,F,-5.0,3484,3082,22.3743,375.5,445
+2459015,"Saint-Amable (Que.)",MÉ ,F,8398,7278,F,F,15.4,3054,2987,36.6816,228.9,446
+2473030,"Bois-des-Filion (Que.)",V  ,F,8383,7712,F,F,8.7,3365,3241,4.2801,1958.6,447
+4711065,"Corman Park No. 344 (Sask.)",RM ,F,8349,8043,T,F,3.8,2777,2722,1978.1359,4.2,448
+3554068,"Kirkland Lake (Ont.)",T  ,F,8248,8616,F,F,-4.3,4308,3768,262.2366,31.5,449
+2461030,"Notre-Dame-des-Prairies (Que.)",V  ,F,8230,7316,F,F,12.5,3662,3570,18.1969,452.3,450
+3560027,"Dryden (Ont.)",CY ,F,8195,8198,F,F,0.0,3482,3283,65.2041,125.7,451
+4805012,"Wheatland County (Alta.)",CM ,F,8164,7889,F,F,3.5,2620,2508,4550.9175,1.8,452
+3532027,"Zorra (Ont.)",TP ,F,8125,8052,F,F,0.9,2994,2887,528.7761,15.4,453
+1207011,"Kings, Subd. C (N.S.)",SC ,F,8121,7943,F,F,2.2,3529,3385,244.1211,33.3,454
+4717029,"Lloydminster (Part) (Sask.)",CY ,F,8118,7840,F,F,3.5,3196,3075,17.3392,468.2,455
+3559012,"Fort Frances (Ont.)",T  ,F,8103,8315,F,F,-2.5,3650,3443,26.8455,301.8,456
+4814024,"Edson (Alta.)",T  ,F,8098,7585,F,F,6.8,3230,3094,29.5443,274.1,457
+1203004,"Digby (N.S.)",MD ,F,7986,8281,F,F,-3.6,4231,3359,1655.9267,4.8,458
+2463060,"Sainte-Julienne (Que.)",MÉ ,F,7983,7182,F,F,11.2,3763,3288,99.2462,80.4,459
+1206004,"Bridgewater (N.S.)",T  ,F,7944,7621,F,F,4.2,3735,3595,13.6038,584.0,460
+4805026,"Drumheller (Alta.)",T  ,F,7932,7785,F,F,1.9,3244,3079,107.9287,73.5,461
+2482020,"Cantley (Que.)",MÉ ,F,7926,5898,F,F,34.4,2912,2748,128.3868,61.7,462
+2402028,"Chandler (Que.)",V  ,F,7914,8278,T,F,-4.4,3556,3362,419.4985,18.9,463
+4617050,"Dauphin (Man.)",CY ,F,7906,8085,F,F,-2.2,3889,3645,12.6523,624.9,464
+2455048,"Marieville (Que.)",V  ,F,7904,7240,F,F,9.2,3328,3128,62.7809,125.9,465
+3547048,"Renfrew (Ont.)",T  ,F,7846,7942,F,F,-1.2,3686,3549,12.7709,614.4,466
+2450072,"Nicolet (Que.)",V  ,F,7827,7928,F,F,-1.3,3363,3156,96.1080,81.4,467
+2446112,"Farnham (Que.)",V  ,F,7809,7747,F,F,0.8,3553,3341,92.0372,84.8,468
+2448028,"Acton Vale (Que.)",V  ,F,7797,7325,T,F,6.4,3489,3271,90.9584,85.7,469
+1214001,"Antigonish, Subd. A (N.S.)",SC ,F,7730,7702,F,F,0.4,3697,2894,927.7940,8.3,470
+5939037,"Columbia-Shuswap C (B.C.)",RDA,F,7695,6762,F,F,13.8,4621,3399,506.3342,15.2,471
+4614036,"Rockwood (Man.)",RM ,F,7692,7654,F,F,0.5,2563,2453,1199.7579,6.4,472
+3540025,"Central Huron (Ont.)",MU ,F,7641,7806,F,F,-2.1,3419,2962,447.6029,17.1,473
+4802022,"Taber (Alta.)",T  ,F,7591,7671,F,F,-1.0,3034,2897,15.0856,503.2,474
+3532012,"South-West Oxford (Ont.)",TP ,F,7589,7782,F,F,-2.5,2667,2588,370.6306,20.5,475
+4813044,"Athabasca County No. 12 (Alta.)",CM ,F,7587,7521,T,F,0.9,3799,2905,6126.4291,1.2,476
+1010025,"Happy Valley-Goose Bay (N.L.)",T  ,F,7572,7969,F,F,-5.0,3226,2726,305.8453,24.8,477
+3511030,"Stone Mills (Ont.)",TP ,F,7568,7337,F,F,3.1,3122,2799,688.2827,11.0,478
+2499025,"Chibougamau (Que.)",V  ,F,7563,7922,F,F,-4.5,3377,3111,699.1632,10.8,479
+3540028,"Goderich (Ont.)",T  ,F,7563,7604,F,F,-0.5,3425,3270,7.9105,956.1,479
+5919046,"Cowichan Valley B (B.C.)",RDA,F,7562,7081,F,F,6.8,3075,2780,306.2327,24.7,481
+5919021,"Ladysmith (B.C.)",T  ,F,7538,6811,T,F,10.7,3303,3185,12.1827,618.7,482
+2434017,"Pont-Rouge (Que.)",V  ,F,7518,7146,F,F,5.2,3122,2939,121.2259,62.0,483
+3507006,"Augusta (Ont.)",TP ,F,7510,7635,F,F,-1.6,2874,2781,314.0590,23.9,484
+3538035,"Plympton-Wyoming (Ont.)",T  ,F,7506,7359,F,F,2.0,3066,2718,318.7639,23.5,485
+2482035,"La Pêche (Que.)",MÉ ,F,7477,6453,F,F,15.9,4492,3067,581.5554,12.9,486
+4810036,"Vermilion River County No. 24 (Alta.)",CM ,F,7467,7524,F,F,-0.8,2796,2633,5518.7089,1.4,487
+5925024,"Comox-Strathcona C (B.C.)",RDA,F,7441,7448,T,F,-0.1,3591,2933,1058.8280,7.0,488
+2451015,"Louiseville (Que.)",V  ,F,7433,7622,F,F,-2.5,3519,3365,62.5886,118.8,489
+2457010,"Carignan (Que.)",V  ,F,7426,5915,F,F,25.5,2697,2639,62.3129,119.2,490
+1314014,"Campbellton (N.B.)",CY ,F,7384,7798,F,F,-5.3,3485,3161,18.6617,395.7,491
+3532038,"East Zorra-Tavistock (Ont.)",TP ,F,7350,7238,F,F,1.5,2657,2568,247.4185,29.7,492
+2487090,"La Sarre (Que.)",V  ,F,7336,7728,F,F,-5.1,3520,3366,148.6844,49.3,493
+1201001,"Barrington (N.S.)",MD ,F,7331,7648,F,F,-4.1,3355,2987,631.9430,11.6,494
+2467025,"Delson (Que.)",V  ,F,7322,7024,F,F,4.2,2782,2741,7.1311,1026.8,495
+4808008,"Innisfail (Alta.)",T  ,F,7316,6943,T,F,5.4,2962,2879,13.0179,562.0,496
+2416013,"Baie-Saint-Paul (Que.)",V  ,F,7288,7290,F,F,0.0,3321,3021,546.2674,13.3,497
+5903045,"Castlegar (B.C.)",CY ,F,7259,7585,T,F,-4.3,3225,3062,19.7993,366.6,498
+4806034,"Olds (Alta.)",T  ,F,7248,6607,F,F,9.7,3190,2997,11.0469,656.1,499
+1010032,"Labrador City (N.L.)",T  ,F,7240,7744,F,F,-6.5,2963,2784,38.8253,186.5,500
+5905014,"Trail (B.C.)",CY ,F,7237,7575,F,F,-4.5,3764,3517,34.7773,208.1,501
+5939019,"Revelstoke (B.C.)",CY ,F,7230,7500,F,F,-3.6,3275,3100,31.9044,226.6,502
+3547003,"McNab/Braeside (Ont.)",TP ,F,7222,6843,F,F,5.5,2934,2689,253.8671,28.4,503
+2475045,"Saint-Hippolyte (Que.)",PE ,F,7219,6039,F,F,19.5,4333,3106,120.6222,59.8,504
+5925022,"Comox-Strathcona B (B.C.)",RDA,F,7219,7013,T,F,2.9,3076,2952,57.6602,125.2,504
+3542005,"Southgate (Ont.)",TP ,F,7167,6907,F,F,3.8,2801,2564,643.9520,11.1,506
+1202006,"Yarmouth (N.S.)",T  ,F,7162,7561,F,F,-5.3,3323,3129,10.5592,678.3,507
+4810001,"Camrose County No. 22 (Alta.)",CM ,F,7160,7278,T,F,-1.6,2754,2591,3331.9797,2.1,508
+3547002,"Arnprior (Ont.)",T  ,F,7158,7192,F,F,-0.5,3335,3158,13.0362,549.1,509
+3532045,"Blandford-Blenheim (Ont.)",TP ,F,7149,7422,T,F,-3.7,2603,2494,382.3351,18.7,510
+3542029,"Hanover (Ont.)",T  ,F,7147,6869,F,F,4.0,3192,3044,9.8061,728.8,511
+3540010,"Bluewater (Ont.)",MU ,F,7120,6919,F,F,2.9,4353,2766,416.9875,17.1,512
+3509010,"Drummond/North Elmsley (Ont.)",TP ,F,7118,6670,F,F,6.7,3237,2683,364.7826,19.5,513
+1102080,"Stratford (P.E.I.)",T  ,F,7083,6314,F,F,12.2,2898,2636,22.4790,315.1,514
+3522012,"Mono (Ont.)",T  ,F,7071,6912,T,F,2.3,2484,2340,277.6744,25.5,515
+3534011,"Aylmer (Ont.)",T  ,F,7069,7158,T,F,-1.2,2793,2696,6.2244,1135.7,516
+3560090,"Kenora, Unorganized (Ont.)",NO ,F,7041,7631,T,F,-7.7,7603,2799,400652.3363,0.0,517
+4811032,"Brazeau County (Alta.)",MD ,F,7040,6606,T,F,6.6,2774,2543,3015.8287,2.3,518
+5921034,"Nanaimo G (B.C.)",RDA,F,7023,6113,T,F,14.9,3165,2987,48.8772,143.7,519
+5933006,"Merritt (B.C.)",CY ,F,6998,7088,F,F,-1.3,2947,2814,24.9448,280.5,520
+2466062,"Hampstead (Que.)",V  ,F,6996,6974,T,F,0.3,2639,2518,1.7898,3908.8,521
+3515023,"Douro-Dummer (Ont.)",TP ,F,6954,6652,F,F,4.5,3442,2559,458.3616,15.2,522
+3515005,"Otonabee-South Monaghan (Ont.)",TP ,F,6934,6669,F,F,4.0,2851,2567,349.2168,19.9,523
+4813028,"Westlock County (Alta.)",MD ,F,6910,6859,F,F,0.7,2589,2410,3174.6049,2.2,524
+4811031,"Drayton Valley (Alta.)",T  ,F,6893,6090,T,F,13.2,2619,2541,12.2730,561.6,525
+4809015,"Rocky Mountain House (Alta.)",T  ,F,6874,6208,F,F,10.7,2719,2615,12.4397,552.6,526
+4802031,"Newell County No. 4 (Alta.)",CM ,F,6862,7137,F,F,-3.9,2366,2178,5903.4743,1.2,527
+1315001,"Saumarez (N.B.)",P  ,F,6837,6963,F,F,-1.8,2911,2614,326.7583,20.9,528
+3542045,"Blue Mountains (Ont.)",T  ,F,6825,6116,F,F,11.6,5619,2939,286.7841,23.8,529
+2440043,"Asbestos (Que.)",V  ,F,6819,6580,F,F,3.6,3429,3230,29.6746,229.8,530
+4609024,"Portage la Prairie (Man.)",RM ,F,6793,6791,F,F,0.0,2474,2183,1964.3216,3.5,531
+2471133,"Rigaud (Que.)",MÉ ,F,6780,6095,F,F,11.2,2923,2732,99.0763,68.4,532
+4811068,"Morinville (Alta.)",T  ,F,6775,6540,F,F,3.6,2401,2287,11.3412,597.4,533
+2404037,"Sainte-Anne-des-Monts (Que.)",V  ,F,6772,6835,F,F,-0.9,3068,2896,263.3109,25.7,534
+3501042,"North Stormont (Ont.)",TP ,F,6769,6855,F,F,-1.3,2514,2391,515.5450,13.1,535
+2497022,"Port-Cartier (Que.)",V  ,F,6758,7034,T,F,-3.9,3010,2836,1101.3061,6.1,536
+5921010,"Nanaimo A (B.C.)",RDA,F,6751,6423,F,F,5.1,2868,2755,60.1067,112.3,537
+3541043,"Arran-Elderslie (Ont.)",MU ,F,6747,6577,F,F,2.6,2791,2610,460.1263,14.7,538
+3539041,"North Middlesex (Ont.)",MU ,F,6740,6901,F,F,-2.3,2421,2307,597.8645,11.3,539
+4801003,"Cypress County (Alta.)",MD ,F,6729,6114,F,F,10.1,2809,2369,13166.1323,0.5,540
+3534005,"Bayham (Ont.)",MU ,F,6727,6375,F,F,5.5,2305,2194,244.9941,27.5,541
+2482025,"Chelsea (Que.)",MÉ ,F,6703,6036,F,F,11.1,2824,2482,111.5522,60.1,542
+4817029,"Slave Lake (Alta.)",T  ,F,6703,6600,F,F,1.6,2342,2254,14.1776,472.8,542
+4815035,"Banff (Alta.)",T  ,F,6700,7135,F,F,-6.1,2844,2568,4.8492,1381.7,544
+1310018,"Kingsclear (N.B.)",P  ,F,6689,6349,T,F,5.4,2490,2365,303.2570,22.1,545
+3507004,"Edwardsburgh/Cardinal (Ont.)",TP ,F,6689,6674,F,F,0.2,2846,2657,311.8252,21.5,545
+3523001,"Puslinch (Ont.)",TP ,F,6689,5885,F,F,13.7,2396,2341,214.4373,31.2,545
+5921032,"Nanaimo F (B.C.)",RDA,F,6680,5546,F,F,20.4,3018,2847,263.4389,25.4,548
+2432040,"Plessisville (Que.)",V  ,F,6677,6756,F,F,-1.2,3072,2985,4.3041,1551.3,549
+2476043,"Brownsburg-Chatham (Que.)",V  ,F,6664,6770,F,F,-1.6,3375,2734,247.0241,27.0,550
+3547056,"Whitewater Region (Ont.)",TP ,F,6631,6520,F,F,1.7,3028,2582,537.9647,12.3,551
+3531016,"St. Marys (Ont.)",T  ,F,6617,6293,F,F,5.1,2733,2618,12.4800,530.2,552
+3526014,"Wainfleet (Ont.)",TP ,F,6601,6258,F,F,5.5,2916,2390,217.2940,30.4,553
+1004019,"Stephenville (N.L.)",T  ,F,6588,7109,F,F,-7.3,3033,2759,35.6851,184.6,554
+3558090,"Thunder Bay, Unorganized (Ont.)",NO ,F,6585,6223,F,F,5.8,6655,2699,97000.4075,0.1,555
+4808039,"Ponoka (Alta.)",T  ,F,6576,6355,T,F,3.5,2771,2669,13.0450,504.1,556
+1001504,"Portugal Cove-St. Philip's (N.L.)",T  ,F,6575,5866,F,F,12.1,2447,2344,57.3542,114.6,557
+2472020,"Pointe-Calumet (Que.)",MÉ ,F,6574,5604,F,F,17.3,2712,2565,4.6267,1420.9,558
+4603053,"Morden (Man.)",T  ,F,6571,6159,T,F,6.7,2783,2692,16.3862,401.0,559
+2409077,"Mont-Joli (Que.)",V  ,F,6568,6579,T,F,-0.2,3046,2927,24.4456,268.7,560
+3541015,"Huron-Kinloss (Ont.)",TP ,F,6515,6224,F,F,4.7,3759,2473,440.5927,14.8,561
+1214006,"Antigonish, Subd. B (N.S.)",SC ,F,6509,6819,F,F,-4.5,2763,2393,522.2091,12.5,562
+3544053,"Muskoka Lakes (Ont.)",TP ,F,6467,6042,F,F,7.0,9211,2679,781.5544,8.3,563
+3514024,"Alnwick/Haldimand (Ont.)",TP ,F,6435,5846,F,F,10.1,2858,2374,398.0812,16.2,564
+1307005,"Beaubassin East / Beaubassin-est (N.B.)",RCR,F,6429,6246,F,F,2.9,3121,2511,291.0376,22.1,565
+1212001,"Pictou, Subd. A (N.S.)",SC ,F,6412,6355,F,F,0.9,3772,2687,770.8730,8.3,566
+3542037,"Chatsworth (Ont.)",TP ,F,6392,6280,F,F,1.8,2742,2366,595.3469,10.7,567
+3509024,"Beckwith (Ont.)",TP ,F,6387,6046,F,F,5.6,2649,2296,240.1179,26.6,568
+4603047,"Stanley (Man.)",RM ,F,6367,5122,T,F,24.3,1646,1613,835.5910,7.6,569
+4812005,"Lakeland County (Alta.)",MD ,F,6365,5306,T,F,20.0,3158,2298,16294.7726,0.4,570
+1308001,"Dundas (N.B.)",P  ,F,6356,6174,F,F,2.9,3649,2588,230.3087,27.6,571
+5955042,"Peace River C (B.C.)",RDA,F,6350,5813,T,F,9.2,2403,2313,582.4899,10.9,572
+2471040,"Coteau-du-Lac (Que.)",MÉ ,F,6346,5573,F,F,13.9,2407,2340,47.0562,134.9,573
+1205004,"Annapolis, Subd. A (N.S.)",SC ,F,6342,6576,F,F,-3.6,3299,2740,614.1800,10.3,574
+4819038,"Peace River (Alta.)",T  ,F,6315,6240,F,F,1.2,2526,2399,24.8721,253.9,575
+1315012,"Beresford (N.B.)",P  ,F,6301,6622,F,F,-4.8,2633,2445,455.9252,13.8,576
+1001509,"Torbay (N.L.)",T  ,F,6281,5474,F,F,14.7,2297,2219,34.8780,180.1,577
+4802021,"Taber (Alta.)",MD ,F,6280,6012,F,F,4.5,1852,1721,4204.3838,1.5,578
+2407047,"Amqui (Que.)",V  ,F,6261,6473,F,F,-3.3,2836,2690,120.8116,51.8,579
+4811018,"Devon (Alta.)",T  ,F,6256,4969,F,F,25.9,2342,2299,8.6267,725.2,580
+2427028,"Beauceville (Que.)",V  ,F,6226,6261,F,F,-0.6,2744,2595,167.5413,37.2,581
+5909009,"Hope (B.C.)",DM ,F,6185,6184,F,F,0.0,2855,2650,41.4215,149.3,582
+6204003,"Iqaluit (Nvt.)",CY ,F,6184,5236,F,F,18.1,2460,2074,52.3429,118.1,583
+4802019,"Coaldale (Alta.)",T  ,F,6177,6008,F,F,2.8,2289,2244,7.9479,777.2,584
+1309036,"Alnwick (N.B.)",P  ,F,6152,6566,F,F,-6.3,2555,2323,734.5685,8.4,585
+5901028,"Kimberley (B.C.)",CY ,F,6139,6484,F,F,-5.3,3219,2827,58.3088,105.3,586
+2468055,"Saint-Rémi (Que.)",V  ,F,6136,5736,F,F,7.0,2372,2330,78.7989,77.9,587
+1212006,"Pictou, Subd. B (N.S.)",SC ,F,6103,6242,F,F,-2.2,2451,2361,770.5751,7.9,588
+2422040,"Lac-Beauport (Que.)",MÉ ,F,6081,5519,F,F,10.2,2336,2199,61.2703,99.2,589
+2447005,"Bromont (Que.)",V  ,F,6049,4808,F,F,25.8,3068,2553,114.4174,52.9,590
+2430030,"Lac-Mégantic (Que.)",V  ,F,5967,5897,F,F,1.2,2873,2715,21.7635,274.2,591
+3514014,"Cramahe (Ont.)",TP ,F,5950,5713,F,F,4.1,2548,2260,201.5635,29.5,592
+2447035,"Shefford (Que.)",CT ,F,5941,5133,F,F,15.7,2376,2203,118.2953,50.2,593
+3541004,"South Bruce (Ont.)",MU ,F,5939,6063,F,F,-2.0,2297,2155,487.1741,12.2,594
+4812014,"St. Paul County No. 19 (Alta.)",CM ,F,5925,6140,T,F,-3.5,2617,2198,3297.7418,1.8,595
+5907047,"Okanagan-Similkameen D (B.C.)",RDA,F,5913,5703,F,F,3.7,2733,2507,916.9887,6.4,596
+3509021,"Perth (Ont.)",T  ,F,5907,6003,F,F,-1.6,3110,2904,10.3595,570.2,597
+3539005,"Southwest Middlesex (Ont.)",MU ,F,5890,6144,F,F,-4.1,2402,2278,427.9178,13.8,598
+2422035,"Stoneham-et-Tewkesbury (Que.)",CU ,F,5866,5266,F,F,11.4,2948,2360,671.6325,8.7,599
+5901035,"East Kootenay C (B.C.)",RDA,F,5866,5753,T,F,2.0,2545,2309,4519.2298,1.3,599
+1215011,"Inverness, Subd. A (N.S.)",SC ,F,5859,6009,F,F,-2.5,3300,2428,2029.6296,2.9,601
+5941019,"Cariboo A (B.C.)",RDA,F,5859,6428,F,F,-8.9,2414,2308,783.3577,7.5,601
+4813018,"Barrhead County No. 11 (Alta.)",CM ,F,5845,5768,F,F,1.3,2490,2096,2404.5507,2.4,603
+4812009,"Bonnyville (Alta.)",T  ,F,5832,5709,F,F,2.2,2394,2269,14.1036,413.5,604
+3549032,"Parry Sound (Ont.)",T  ,F,5818,6124,F,F,-5.0,2781,2514,13.3324,436.4,605
+1207012,"Kentville (N.S.)",T  ,F,5815,5610,F,F,3.7,2662,2558,17.3536,335.1,606
+4817027,"Big Lakes (Alta.)",MD ,F,5805,5845,F,F,-0.7,2215,1980,13892.9114,0.4,607
+4618031,"Gimli (Man.)",RM ,F,5797,5158,T,F,12.4,5025,2675,319.2462,18.2,608
+1310028,"Douglas (N.B.)",P  ,F,5774,5719,F,F,1.0,2286,2139,1446.4962,4.0,609
+1303008,"Lincoln (N.B.)",P  ,F,5764,5548,F,F,3.9,2290,2221,159.8305,36.1,610
+3558011,"Oliver Paipoonge (Ont.)",MU ,F,5757,5862,F,F,-1.8,2155,2058,350.2729,16.4,611
+2462007,"Saint-Félix-de-Valois (Que.)",MÉ ,F,5755,5465,F,F,5.3,2474,2315,87.8523,65.5,612
+4815007,"Crowsnest Pass (Alta.)",T  ,F,5749,6262,F,F,-8.2,3004,2633,373.0694,15.4,613
+5955021,"Peace River D (B.C.)",RDA,F,5749,5857,F,F,-1.8,2274,2076,11670.0970,0.5,613
+2471050,"Les Cèdres (Que.)",MÉ ,F,5732,5128,F,F,11.8,2165,2113,77.8509,73.6,615
+3557095,"Algoma, Unorganized, North Part (Ont.)",NO ,F,5717,6114,F,F,-6.5,5307,2409,44096.9725,0.1,616
+2463055,"Saint-Calixte (Que.)",MÉ ,F,5687,4912,F,F,15.8,3504,2530,143.3273,39.7,617
+2459035,"Contrecoeur (Que.)",V  ,F,5678,5222,F,F,8.7,2519,2411,61.1917,92.8,618
+4810016,"Beaver County (Alta.)",CM ,F,5676,5644,F,F,0.6,2126,1989,3319.1028,1.7,619
+4610035,"Macdonald (Man.)",RM ,F,5653,5320,F,F,6.3,1878,1813,1156.6183,4.9,620
+1312019,"Grand Falls / Grand-Sault (N.B.)",TV ,F,5650,5858,F,F,-3.6,2475,2371,18.0627,312.8,621
+3509015,"Tay Valley (Ont.)",TP ,F,5634,5440,F,F,3.6,3511,2086,527.4646,10.7,622
+2446075,"Lac-Brome (Que.)",V  ,F,5629,5444,F,F,3.4,3275,2434,205.1360,27.4,623
+3556076,"Hearst (Ont.)",T  ,F,5620,5825,F,F,-3.5,2547,2402,98.6660,57.0,624
+3512030,"Tweed (Ont.)",MU ,F,5614,5612,F,F,0.0,2709,2283,896.9836,6.3,625
+2460005,"Charlemagne (Que.)",V  ,F,5594,5662,F,F,-1.2,2614,2526,2.1644,2584.5,626
+4621064,"Flin Flon (Part) (Man.)",CY ,F,5594,6000,F,F,-6.8,2612,2361,13.8785,403.1,626
+4621045,"The Pas (Man.)",T  ,F,5589,5800,T,F,-3.6,2369,2206,47.8254,116.9,628
+2432033,"Princeville (Que.)",V  ,F,5571,5703,F,F,-2.3,2370,2240,194.0051,28.7,629
+2434025,"Donnacona (Que.)",V  ,F,5564,5479,F,F,1.6,2540,2412,20.0226,277.9,630
+3546015,"Minden Hills (Ont.)",TP ,F,5556,5312,F,F,4.6,6220,2397,847.7594,6.6,631
+5955040,"Peace River B (B.C.)",RDA,F,5538,4997,F,F,10.8,1835,1636,86211.9121,0.1,632
+3546024,"Dysart and Others (Ont.)",TP ,F,5526,4924,F,F,12.2,6861,2345,1474.0743,3.7,633
+1211009,"Cumberland, Subd. C (N.S.)",SC ,F,5525,5216,F,F,5.9,4013,2245,896.4156,6.2,634
+4810028,"Vegreville (Alta.)",T  ,F,5519,5376,F,F,2.7,2538,2379,13.4891,409.1,635
+1207021,"Kings, Subd. D (N.S.)",SC ,F,5499,5167,F,F,6.4,2474,2190,264.8625,20.8,636
+1307052,"Shediac (N.B.)",T  ,F,5497,4892,F,F,12.4,2437,2223,11.9740,459.1,637
+3556042,"Cochrane (Ont.)",T  ,F,5487,5690,F,F,-3.6,2492,2281,538.7636,10.2,638
+4818015,"Greenview No. 16 (Alta.)",MD ,F,5464,5439,F,F,0.5,2064,1931,32994.1382,0.2,639
+5921030,"Nanaimo E (B.C.)",RDA,F,5462,4820,F,F,13.3,2745,2434,75.1097,72.7,640
+1002024,"Marystown (N.L.)",T  ,F,5436,5908,F,F,-8.0,2403,2061,61.9684,87.7,641
+4807054,"Wainwright (Alta.)",T  ,F,5426,5117,F,F,6.0,2310,2150,8.5499,634.6,642
+4807026,"Stettler (Alta.)",T  ,F,5418,5215,F,F,3.9,2268,2189,9.5037,570.1,643
+1001409,"Bay Roberts (N.L.)",T  ,F,5414,5237,F,F,3.4,2192,2026,23.9204,226.3,644
+1307009,"Sackville (N.B.)",T  ,F,5411,5361,F,F,0.9,2627,2243,74.3217,72.8,645
+3540063,"Ashfield-Colborne-Wawanosh (Ont.)",TP ,F,5409,5411,F,F,0.0,2920,1958,587.0674,9.2,646
+2426070,"Saint-Lambert-de-Lauzon (Que.)",PE ,F,5401,4857,F,F,11.2,2148,2021,107.1306,50.4,647
+1315029,"Shippagan (N.B.)",P  ,F,5370,5552,T,F,-3.3,2837,2225,207.2522,25.9,648
+1215006,"Inverness, Subd. B (N.S.)",SC ,F,5369,5769,F,F,-6.9,2591,2072,751.8753,7.1,649
+3534042,"West Elgin (Ont.)",MU ,F,5349,5464,F,F,-2.1,2216,2079,322.5152,16.6,650
+4803018,"Willow Creek No. 26 (Alta.)",MD ,F,5337,5412,F,F,-1.4,1776,1654,4560.2177,1.2,651
+3552026,"Espanola (Ont.)",T  ,F,5314,5449,F,F,-2.5,2331,2217,82.3664,64.5,652
+5951051,"Bulkley-Nechako A (B.C.)",RDA,F,5290,5696,F,F,-7.1,2131,1931,3687.9966,1.4,653
+2421045,"Boischatel (Que.)",MÉ ,F,5287,4303,F,F,22.9,1971,1926,20.9345,252.5,654
+3507024,"Gananoque (Ont.)",T  ,F,5285,5167,F,F,2.3,2453,2314,7.0115,753.8,655
+3515044,"Galway-Cavendish and Harvey (Ont.)",TP ,F,5284,4372,F,F,20.9,5407,2234,848.2601,6.2,656
+1007013,"Clarenville (N.L.)",T  ,F,5274,5104,F,F,3.3,2250,2049,140.7880,37.5,657
+2471025,"Saint-Zotique (Que.)",VL ,F,5251,4158,F,F,26.3,2267,2130,25.1934,208.4,658
+2459025,"Verchères (Que.)",MÉ ,F,5243,4782,F,F,9.6,2162,2114,73.2412,71.6,659
+2442088,"Windsor (Que.)",V  ,F,5239,5321,F,F,-1.5,2312,2273,14.2936,366.5,660
+2482030,"Pontiac (Que.)",MÉ ,F,5238,4643,F,F,12.8,2468,2003,444.8346,11.8,661
+2457025,"McMasterville (Que.)",MÉ ,F,5234,3984,F,F,31.4,2109,2066,3.1016,1687.5,662
+3538019,"Petrolia (Ont.)",T  ,F,5222,4849,F,F,7.7,2082,2008,12.6839,411.7,663
+4805041,"Kneehill County (Alta.)",MD ,F,5218,5319,F,F,-1.9,1849,1720,3380.0372,1.5,664
+5951043,"Smithers (B.C.)",T  ,F,5217,5414,F,F,-3.6,2172,2080,15.6875,332.6,665
+4807019,"Stettler County No. 6 (Alta.)",CM ,F,5216,5357,F,F,-2.6,1846,1727,4008.7171,1.3,666
+2455057,"Richelieu (Que.)",V  ,F,5208,4851,F,F,7.4,2122,2068,31.0222,167.9,667
+2466117,"Sainte-Anne-de-Bellevue (Que.)",V  ,F,5197,5062,T,F,2.7,2134,2009,10.5684,491.7,668
+4714051,"Melfort (Sask.)",CY ,F,5192,5559,F,F,-6.6,2377,2218,14.7795,351.3,669
+2466047,"Montréal-Ouest (Que.)",V  ,F,5184,5172,T,F,0.2,1928,1858,1.4069,3684.7,670
+3560034,"Sioux Lookout (Ont.)",MU ,F,5183,5336,F,F,-2.9,2080,1923,378.6131,13.7,671
+3509039,"Lanark Highlands (Ont.)",TP ,F,5180,4795,F,F,8.0,3036,2113,1033.2996,5.0,672
+5935802,"Tsinstikeptum  9 (B.C.)",IRI,F,5171,5022,F,F,3.0,2501,2367,6.8295,757.2,673
+2455023,"Saint-Césaire (Que.)",V  ,F,5151,4850,F,F,6.2,2185,2080,83.5505,61.7,674
+3522021,"Shelburne (Ont.)",T  ,F,5149,4213,T,F,22.2,1902,1850,6.4449,798.9,675
+1315008,"Bathurst (N.B.)",P  ,F,5144,5494,F,F,-6.4,2272,1995,1504.2322,3.4,676
+2437235,"Notre-Dame-du-Mont-Carmel (Que.)",PE ,F,5131,5055,F,F,1.5,2122,2044,128.3253,40.0,677
+2467010,"Saint-Philippe (Que.)",MÉ ,F,5121,3892,F,F,31.6,1968,1926,62.2218,82.3,678
+1311006,"Woodstock (N.B.)",TV ,F,5113,5231,T,F,-2.3,2288,2159,13.4118,381.2,679
+2454008,"Saint-Pie (Que.)",V  ,F,5109,4927,T,F,3.7,2133,1995,109.0287,46.9,680
+4812018,"St. Paul (Alta.)",T  ,F,5106,5061,F,F,0.9,2011,1963,6.8624,744.1,681
+5917029,"Capital G (B.C.)",RDA,F,5101,4307,F,F,18.4,4860,2638,187.4558,27.2,682
+4801018,"Redcliff (Alta.)",T  ,F,5096,4372,F,F,16.6,1968,1902,10.5052,485.1,683
+2471100,"Hudson (Que.)",V  ,F,5088,4796,F,F,6.1,2160,2075,21.7467,234.0,684
+1205014,"Annapolis, Subd. C (N.S.)",SC ,F,5085,5085,F,F,0.0,2400,2132,207.5537,24.5,685
+4602075,"Ritchot (Man.)",RM ,F,5051,4958,F,F,1.9,1745,1706,333.5282,15.1,686
+2422005,"Sainte-Catherine-de-la-Jacques-Cartier (Que.)",V  ,F,5021,4681,F,F,7.3,2045,1928,121.1537,41.4,687
+1303011,"Burton (N.B.)",P  ,F,5019,5000,F,F,0.4,1838,1753,259.4836,19.3,688
+3540055,"North Huron (Ont.)",TP ,F,5015,4984,F,F,0.6,2175,2064,178.9778,28.0,689
+4813031,"Westlock (Alta.)",T  ,F,5008,4819,F,F,3.9,2142,2061,9.6425,519.4,690
+2462047,"Chertsey (Que.)",MÉ ,F,5006,4112,F,F,21.7,4105,2391,287.0238,17.4,691
+2441038,"Cookshire-Eaton (Que.)",V  ,F,5004,5145,T,F,-2.7,2049,1943,295.9346,16.9,692
Index: client.c
===================================================================
--- client.c	(revision 1)
+++ client.c	(revision 66)
@@ -13,11 +13,53 @@
 #include "storage.h"
 #include <stdbool.h>
 #include <time.h>
+#include <stdlib.h>
+#include <math.h>
 #define LOGGING 0
+#define TESTTIMEOUT	10		// How long to wait for each test to run.
+#define SERVEREXEC	"./server"	// Server executable file.
+#define SERVEROUT	"default.serverout"	// File where the server's output is stored.
+#define SERVEROUT_MODE	0666		// Permissions of the server ouptut file.
+#define ONETABLE_CONF			"conf-onetable.conf"	// Server configuration file with one table.
+#define SIMPLETABLES_CONF		"conf-simpletables.conf"	// Server configuration file with simple tables.
+#define COMPLEXTABLES_CONF		"conf-complextables.conf"	// Server configuration file with complex tables.
+#define DUPLICATE_COLUMN_TYPES_CONF     "conf-duplicatetablecoltype.conf"        // Server configuration file with duplicate column types.
+#define BADTABLE	"bad table"	// A bad table name.
+#define BADKEY		"bad key"	// A bad key name.
+#define KEY		"somekey"	// A key used in the test cases.
+#define KEY1		"somekey1"	// A key used in the test cases.
+#define KEY2		"somekey2"	// A key used in the test cases.
+#define KEY3		"somekey3"	// A key used in the test cases.
+#define KEY4		"somekey4"	// A key used in the test cases.
+#define VALUESPC	"someval 4"	// A value used in the test cases.
+#define INTCOL		"col"		// An integer column
+#define INTVALUE	"22"		// An integer value
+#define INTCOLVAL	"col 22"	// An integer column name and value
 
+// These settings should correspond to what's in the config file.
+#define SERVERHOST	"localhost"	// The hostname where the server is running.
+#define SERVERPORT	4848		// The port where the server is running.
+#define SERVERUSERNAME	"admin"		// The server username
+#define SERVERPASSWORD	"dog4sale"	// The server password
+//#define SERVERPUBLICKEY	"keys/public.pem"	// The server public key
+//#define DATADIR		"./mydata/"	// The data directory.
+#define TABLE		"inttbl"	// The table to use.
+#define INTTABLE	"inttbl"	// The first simple table.
+#define FLOATTABLE	"floattbl"	// The second simple table.
+#define STRTABLE	"strtbl"	// The third simple table.
+#define THREECOLSTABLE	"threecols"	// The first complex table.
+#define FOURCOLSTABLE	"fourcols"	// The second complex table.
+#define SIXCOLSTABLE	"sixcols"	// The third complex table.
+#define MISSINGTABLE	"missingtable"	// A non-existing table.
+#define MISSINGKEY	"missingkey"	// A non-existing key.
 
+/*
+ * @brief ptr to a file which will be used in logger function
+ * 
+ * */
 FILE *file_ptr;
 
+
 /**
  * @brief Start a client to interact with the storage server.
  *
@@ -29,169 +71,51 @@
 int main(int argc, char *argv[]) {
 
 	//global variables
-	void *conn;
+	void *test_conn;
+	test_conn = storage_connect("localhost",5628);
+	storage_auth("admin","dog4sale",test_conn);
+	char **test_keys = (char**)malloc(sizeof(char*)*40);
+	int i;
+	for (i = 0; i < MAX_RECORDS_PER_TABLE; i++) {
+		test_keys[i] = (char*)malloc(MAX_KEY_LEN); 
+		strncpy(test_keys[i], "", sizeof(test_keys[i]));
+	}
+	struct storage_record record;
+	struct storage_record record1;
+	struct storage_record record2;
 	int status;
-	char inp_value[1024];
-	struct storage_record r;
-	char selection[1024];
-	char SERVERHOST[MAX_HOST_LEN];
-	int SERVERPORT;
-	char SERVERUSERNAME[MAX_USERNAME_LEN];
-	char SERVERPASSWORD[MAX_ENC_PASSWORD_LEN];
-	char TABLE [MAX_TABLE_LEN];
-    	char KEY[MAX_KEY_LEN];
-	bool connected[2] = {false};
-	
+	memset(&record, 0, sizeof record);
+	strncpy(record.value, "col -2", sizeof record.value);
+	status = storage_set(INTTABLE, KEY1, &record, test_conn);
+	strncpy(record.value, "col 2", sizeof record.value);
+	status = storage_set(INTTABLE, KEY2, &record, test_conn);
+	strncpy(record.value, "col 4", sizeof record.value);
+	status = storage_set(INTTABLE, KEY3, &record, test_conn);
 
-	if (LOGGING == 0) {
+	strncpy(record.value, "col -2", sizeof record.value);
+	status = storage_set(FLOATTABLE, KEY1, &record, test_conn);
+	strncpy(record.value, "col 2", sizeof record.value);
+	status = storage_set(FLOATTABLE, KEY2, &record, test_conn);
+	strncpy(record.value, "col 4", sizeof record.value);
+	status = storage_set(FLOATTABLE, KEY3, &record, test_conn);
 
-	file_ptr = NULL;
-
-	}
+	strncpy(record.value, "col abc", sizeof record.value);
+	status = storage_set(STRTABLE, KEY1, &record, test_conn);
+	strncpy(record.value, "col def", sizeof record.value);
+	status = storage_set(STRTABLE, KEY2, &record, test_conn);
+	strncpy(record.value, "col abc def", sizeof record.value);
+	status = storage_set(STRTABLE, KEY3, &record, test_conn);
 	
-	else if(LOGGING == 1) {
-
-	file_ptr = stdout;
-
-	}
-	else if(LOGGING == 2) {
+    strncpy(record1.value, "", sizeof record1.value);
+    status = storage_get(INTTABLE, KEY2, &record1, test_conn);
 	
-	time_t curr_time;
-	char filename[31];
-	struct tm *curr_tm;
-	time(&curr_time);
-	curr_tm = localtime(&curr_time);
-	strftime(filename, 31, "Client-%Y-%m-%d-%H-%M-%S.log",curr_tm);
-	file_ptr = fopen(filename, "w");
-
-	}
+    memset(&record2, 0, sizeof record2);
+    strncpy(record2.value, "col 8", sizeof record2.value);
+    status = storage_set(INTTABLE, KEY2, &record2, test_conn);
+    
+    strncpy(record1.value, "col 88", sizeof record1.value);
+    status = storage_set(INTTABLE, KEY2, &record1, test_conn);
+    
+	return 0;
 	
-	
-
-	do {
-
-	//printing list of options
-	printf("> --------------------- \n");
-	printf("> 1) Connect \n");
-	printf("> 2) Authenticate \n");
-	printf("> 3) Get \n");
-	printf("> 4) Set \n");
-	printf("> 5) Disconnect \n");
-	printf("> 6) Exit \n");
-	printf("> --------------------- \n");
-
-	//reading input from the client
-	printf("> Please enter your selection: ");
-	scanf("%s",selection);
-
-    // Connect to server
-	if(!strcmp(selection,"1")){
-		//reading input from client
-		printf("> Please input the host name: ");
-		scanf(" ");
-		scanf("%s",SERVERHOST);
-		printf("> Please input Port: ");
-		scanf(" ");
-		scanf("%d",&SERVERPORT);
-		printf("> Connecting to %s:%d ...\n",SERVERHOST,SERVERPORT);
-		
-		conn = storage_connect(SERVERHOST, SERVERPORT);
-			if(!conn) {
-				printf("Cannot connect to server @ %s:%d. Error code: %d.\n",
-						SERVERHOST, SERVERPORT, errno);
-				return 0;
-		}
-
-		//delay necessary for confirmation message to show up
-		int i ;
-		for(i = 0; i <= 100000000;i++);
-		connected[0] = true;
-	}
-
-    // Authenticate the client.
-	else if(!strcmp(selection,"2")&&connected[0]) {
-		//reading input from client
-		printf("> Please input username: ");
-		scanf(" ");
-		scanf("%s",SERVERUSERNAME);
-		printf("> Please input password: ");
-		scanf(" ");
-		scanf("%s",SERVERPASSWORD);
-
-		status = storage_auth(SERVERUSERNAME, SERVERPASSWORD, conn);
-		if(status != 0) {
-			printf("storage_auth failed with username '%s' and password '%s'. " \
-           "Error code: %d.\n", SERVERUSERNAME, SERVERPASSWORD, errno);
-			storage_disconnect(conn);
-			return status;
-		}
-		printf("storage_auth: successful.\n");
-		connected[1] = true;
-	}
-
-  // Issue storage_set
-	else if(!strcmp(selection,"4") && connected[1]) {
-		//reading input from client
-		printf("> Please input table: ");
-		scanf(" ");
-		scanf("%s",TABLE);
-		printf("> Please input a key: ");
-		scanf(" ");
-		scanf("%s",KEY);
-		printf("> Please input a value: ");
-		scanf(" ");
-		scanf("%s",inp_value);
-
-		strncpy(r.value, inp_value, sizeof r.value);
-		status = storage_set(TABLE, KEY, &r, conn);
-		if(status != 0) {
-			printf("storage_set failed. Error code: %d.\n", errno);
-			storage_disconnect(conn);
-			return status;
-		}
-		printf("> storage_set: successful.\n");
-	}
-  // Issue storage_get
-	else if(!strcmp(selection,"3") && connected[1]) {
-		//reading input from client
-		printf("> Please select a table from the database: ");
-		scanf(" ");
-		scanf("%s",TABLE);
-		printf("> Please input a key: ");
-		scanf(" ");
-		scanf("%s",KEY);
-		status = storage_get(TABLE, KEY, &r, conn);
-		if(status != 0) {
-			printf("storage_get failed. Error code: %d.\n", errno);
-			storage_disconnect(conn);
-			return status;
-		}
-		printf("> storage_get: the value returned for key '%s' is '%s'.\n",KEY, r.value);
-	}
-    // Disconnect from server
-	else if(!strcmp(selection,"5") && connected[0] && connected[1]) {
-		status = storage_disconnect(conn);
-		if(status != 0) {
-
-			printf("storage_disconnect failed. Error code: %d.\n", errno);
-			return status;
-		}
-		//delay necessary for confirmation message to show up
-		int i ;
-		for(i = 0; i <= 100000000;i++);
-		connected[0] = true;
-		}
-
-	// Exit
-	else if(!strcmp(selection,"6")) {
-
-		if(file_ptr)
-			fclose(file_ptr);
-
-		return 0;
-		}
-	else
-		printf("> Invalid command.\n");
-	}while(true);
-
 }
Index: utils.c
===================================================================
--- utils.c	(revision 1)
+++ utils.c	(revision 66)
@@ -18,23 +18,88 @@
 #include <unistd.h>
 #include "utils.h"
 #include <errno.h>
+#include "storage.h"
 
-//changes by vincent aulia, Tue 4 Feb, 17.03
+
+record_struct* find_record(char *table, char *key, table_list *list)
+{
+    //return -1 if key cannot be found
+    //else return 0
+    int i;//loop counter for table
+    int j;//loop counter for record_struct
+    int keyInt = keymaker(key);
+    for(i=0;i<100;i++)
+    {
+        if(list->Table[i].table_name[0] != '\0')//if tablename is not null
+        {//then go in
+            if(!strcmp(list->Table[i].table_name, table))//if name is equal
+            {
+                    if(list->Table[i].RecordStruct[keyInt] != NULL)//if record struct pointer is not null
+                    { 
+                        record_struct* copystruct = list->Table[i].RecordStruct[keyInt];
+                        while(copystruct != NULL)//while its not the end of the key linked list
+                        {
+                            if(!strcmp(copystruct->key, key))//if key is equal
+                                {
+                                return copystruct;
+                                }
+                            else//if not the same keep continue traverse node
+                                {
+                                copystruct = copystruct->next;
+                                }
+                        }
+                        
+                    } 
+                    
+              return NULL; //record not found, return NULL  
+            }
+            
+        }
+    }
+     return NULL; //record not found, return NULL
+}
+bool is_number(char* value)
+{
+    bool isNumber = true;
+    int i = 0;
+    while(isNumber && value[i] != '\0')
+    {
+        if(i == 0 && value[i] == '-')
+        {
+            isNumber = true;
+            i++;
+        }
+        else if(i == 0 && value[i] == '+')
+        {
+            isNumber = true;
+            i++;
+        }
+        else if(value[i] >= '0' && value[i] <= '9')
+        {
+            isNumber = true;
+            i++;
+        }
+        else if(value[i] == '-' || value[i] == '+')
+        {
+            isNumber = false;
+        }
+        else isNumber = false;
+    }
+    return isNumber;
+}
+
 /**
-* added a basic keymaker function
-* added a basic record insert function //need to add error bool later
-* added a basic record search function --//-- 
-* added a basic address search function
-* added a basic delete function
-*/
-	//a function to make an int key from string key
-int keymaker(char* key)
+ * @brief This is a function to generate a key from a string.
+ * @param key String to be hashed into an integer key
+ * @return Returns the integer key
+ */
+int keymaker(const char* key)
 {
-	int address_record; //address to the record
+	int address_record; ///Address to the record
 	int total = 0;
         int first_two=0;
 	int len = strlen(key);
-	//get a certain number from multiplication of ascii char
+	///Get a certain number from multiplication of ascii char
 	int n;
         int m;
 	for(n = 0; n < len; n++)
@@ -55,113 +120,454 @@
 		} 
 	}
         int first_two_mod = (first_two % 4 + 1);
-        //makes a key from the result of both above
+        ///Makes a key from the result of both above
         address_record = (total*first_two_mod) % 997;
 	return address_record;
 
-}//works
+}
 
-	//a function to insert record to table
-void record_insert(int index, char *key, char *value, record_element** table)
-{
-	record_element* element; //make a new record
-	element = (record_element*)malloc(sizeof(record_element)); 
-	element->key = key;
-	element->value = value;
-	element->next = NULL;
-	if (table[index] == NULL)	//if address is empty just put one in
-	{
-		table[index] = element;
-	}
-	else if (table[index] != NULL)	//if collision put in next NULL pointer in linked list
-	{
-		record_element* copyelement = table[index];
-		while(copyelement->next != NULL)
-		{
-			copyelement = copyelement->next;
-		}
-		copyelement->next = element;
-	}
-	return;
-}//works
 
-	//a function to return THE ADDRESS of a record element
-record_element* key_search(char* key, record_element** table, int index)
+bool find_table(char* table, table_list* table_ptr)
 {
-	record_element* copyelement = NULL;
-        record_element* copyaddress = NULL;	//initialize pointer to address	
-	copyelement = table[index];
-        copyaddress = table[index];
-	while (copyelement != NULL)
-	{
-                if(strcmp(copyelement->key, key) == 0)
-                   return copyaddress;
-                copyelement = copyelement->next;		
-	}
-	return NULL; //if not found return nothing
+    int i; //integer which holds the current index location while traversing through table_ptr
+    for(i = 0; table_ptr->Table[i].table_name[0] != NULL && i < MAX_TABLES; i++) {
+        //check whether we are at the correct spot by looking at table names
+        if(!strcmp(table_ptr->Table[i].table_name,table)) {
+            //table found
+            return true;
+            
+        }
+    }//else table not found
+    return false;
 }
-
-	//a function to search THE LOCATION INSIDE THE ADDRESS a record element
-record_element* record_search(char* key, record_element** table, int index)
+int record_get(char* table, char* key, table_list* list, char *append, int *metadata_ptr)
 {
-	record_element* copyelement = NULL;	//initialize pointer to address	
-	copyelement = table[index];
-	while (copyelement != NULL)
-	{
-                if(strcmp(copyelement->key, key) == 0)
-                   return copyelement;
-                copyelement = copyelement->next;		
-	}
-	return NULL; //if not found return nothing
+    bool found_table = find_table(table, list);
+    if(found_table)
+    {
+        record_struct* copystruct = find_record(table, key, list);
+        if(copystruct != NULL)//found record struct
+        {
+	    *metadata_ptr = copystruct->metadata;	
+            int i;
+            for(i=0;i<MAX_COLUMNS_PER_TABLE && copystruct->column.column_name[i][0] != '\0';i++)
+            {
+                    strcat(append, copystruct->column.column_name[i]);//if the value here is not null
+                    strcat(append, " ");
+                    strcat(append, copystruct->column.value[i]);
+                    if(copystruct->column.value[i+1][0] != '\0')//check if there is more value later
+                    {
+                    strcat(append, " ");
+                    strcat(append, ",");
+                    strcat(append, " ");
+                    }
+            }
+            return 0;
+        }
+        else
+        {
+            return -2;
+        }
+    }
+    else
+    {
+        return -3;
+    }
+    
 }
-	
-	//a function to delete a record element
-bool record_delete(char* key, record_element** table, int index)
+int delete_record(table_list* list, char* table, char* key)
 {
-        
-	record_element* tmp_ptr_list1;
-        tmp_ptr_list1 = table[index];
-        record_element* tmp_ptr_list2;
-        tmp_ptr_list2 = tmp_ptr_list1;
-        if(!tmp_ptr_list1) //nothing in the list, just return
+    //return -1 if key cannot be found
+    //else return 0
+    int i;//loop counter for table
+    int j;//loop counter for record_struct
+    int keyInt = keymaker(key);
+    for(i=0;i<100 && list->Table[i].table_name[0] != '\0';i++)
+    {
+       //then go in
+            if(!strcmp(list->Table[i].table_name, table))//if name is equal
+            {
+                    if(list->Table[i].RecordStruct[keyInt] != NULL)//if record struct pointer is not null
+                    {
+                        //make copy pointer to key struct and the one next to it
+                        record_struct* headstruct = list->Table[i].RecordStruct[keyInt];
+                        record_struct* copycopystruct = headstruct;
+                        if(!strcmp(list->Table[i].RecordStruct[keyInt]->key, key))//delete head
+                                {
+                                list->Table[i].RecordStruct[keyInt] = copycopystruct->next;
+                                free(copycopystruct); //free main struct
+                                return 0;
+                                }
+                              record_struct* copystruct = headstruct->next;
+                        while(copystruct != NULL)//while its not the end of the key linked list
+                        {
+                            if(!strcmp(copystruct->key, key))//if key is equal
+                                {
+                                copycopystruct->next = copystruct->next;
+                                free(copystruct); //free main struct
+                                return 0;
+                                }
+                            else//if not the same keep continue traverse node
+                                {
+                                copystruct = copystruct->next;
+                                copycopystruct = copycopystruct->next;
+                                }
+                        }
+                        
+                    } return -2;
+                    
+                
+            } 
+    }
+    return -3;
+}
+int create_record(int option,int i,char *key, char *value, table_list *List, config_params params, int metadata){
+			char tmp_d[1024];
+	        memset(tmp_d,0,sizeof(tmp_d));
+	        strncpy(tmp_d,value,sizeof(tmp_d));
+	        char *tmp_chard = strtok(tmp_d," ");//gives me the column name
+	        int d;
+	        for(d = 0; d < MAX_COLUMNS_PER_TABLE && params.tablepara[i].table_columns[d][0] != NULL && tmp_chard;d++) {
+	                //create column name
+	                if(strcmp(tmp_chard,params.tablepara[i].table_columns[d])) //check whether column exists and its in order
+	                    return -4;
+	                tmp_chard = strtok(NULL,","); //get the value for the column
+	                tmp_chard = strtok(NULL," ");
+	        }     
+	        if (tmp_chard != NULL || params.tablepara[i].table_columns[d][0] != NULL)
+	            return -4;
+	        char tmp_c[1024];
+	        strncpy(tmp_c,value,sizeof(tmp_c));
+	        int j;
+	        bool insert_head = false;
+	        int hash = keymaker(key);
+	        record_struct *tmp_record = NULL;
+	        record_struct *ptr_record = NULL;
+	        char *tmp_char = strtok(tmp_c," ");//gives me the column name
+	        if(option == 2) {
+	                ptr_record = find_record(List->Table[i].table_name,key,List);
+	        }
+	        else {
+	            //if record doesn't exist, create it and parse for invalid input parameters
+	            tmp_record =  List->Table[i].RecordStruct[hash];
+	            if(! List->Table[i].RecordStruct[hash]){//insert at the head
+	                List->Table[i].RecordStruct[hash] = (record_struct*)malloc(sizeof(record_struct));//insert at the head  
+	                List->Table[i].RecordStruct[hash]->next = NULL;
+	                insert_head = true;
+	            }
+	            else {
+	                while(tmp_record->next) 
+	                    tmp_record = tmp_record->next;
+	                tmp_record->next = (record_struct*)malloc(sizeof(record_struct));//insert at the end 
+	                tmp_record->next->next = NULL;
+	                
+	            }
+	        }
+	        if(option == 1) {
+	        	
+	        	if(insert_head){
+	            ptr_record =  List->Table[i].RecordStruct[hash];
+	            strncpy(ptr_record->key,key,MAX_KEY_LEN);
+	        	}
+	        	else {
+	        		ptr_record = tmp_record->next;
+	        		strncpy(ptr_record->key,key,MAX_KEY_LEN);
+	        	}
+			ptr_record->metadata = 1;
+	        }
+		else if(option == 2) {
+
+		if(metadata == 0)
+			ptr_record->metadata++;
+			//don't do anything		
+		else if(ptr_record->metadata != metadata) 
+			return -5;
+		
+		else ptr_record->metadata++;
+		
+		}
+	        for(j = 0; j < MAX_COLUMNS_PER_TABLE && params.tablepara[i].table_columns[j][0] != NULL && tmp_char;j++) {
+	                //create column name
+	                if(strcmp(tmp_char,params.tablepara[i].table_columns[j])) //check whether column exists and its in order
+	                    return -4;
+	                strncpy(ptr_record->column.column_name[j],params.tablepara[i].table_columns[j], MAX_COLNAME_LEN);
+	                //check for the type of value for the column
+	                tmp_char = strtok(NULL,","); //get the value for the column
+	                if(params.tablepara[i].column_types[j] != -1){
+	                    //check if value has the according size
+	                    if(params.tablepara[i].column_types[j] < strlen(tmp_char))
+	                            return -4; //invalid param. string doesn't abide by the size
+	                    //copy value to the key
+	                    strncpy(ptr_record->column.value[j],tmp_char,800);  
+	                    ptr_record->column.type[j] = params.tablepara[i].column_types[j];
+	                }
+	                //it is a character, malloc for 2^32
+	               else {
+	               //check if the value is a number
+	                        if(!is_number(tmp_char))
+	                            return -4;
+	                            //copy value to the key
+	                            strncpy(ptr_record->column.value[j],tmp_char,800);
+	                            ptr_record->column.type[j] = params.tablepara[i].column_types[j];
+	                    }
+	                    tmp_char = strtok(NULL," ");//get the column name
+	                } 
+	        
+	         return 0;
+             
+}
+int insert_key(const char *table, const char *key, const char* value, table_list *table_ptr, const config_params params, int metadata) {
+	    //create hashing key for value
+	    int hash_key =  keymaker(key);  
+	    bool found = false; //true if table found false otherwise
+	    char tmp_c[1024];
+	    strncpy(tmp_c,value,1024); //copy of value
+	    int j; //integer for keeping track of the columns being searched
+	    //loop through table list until table is found
+	    int i; //integer which holds the current index location while traversing through table_ptr
+	    for(i = 0; table_ptr->Table[i].table_name[0] != 0 && i < MAX_TABLES; i++) {
+	        //check whether we are at the correct spot by looking at table names
+	        if(!strcmp(table_ptr->Table[i].table_name,table)) {
+	            //table found, now insert key
+	            found = true;
+	            break;
+	        }
+	    }
+	    
+	    if(!found) //table not found
+	        return -3;
+	     //create columns and insert values
+	     record_struct * tmp = find_record(table,key,table_ptr);
+	     if(tmp)
+	         //update value for the record
+	         return create_record(2,i,key,value,table_ptr,params,metadata);
+	    else {
+	        //insert new value
+	        return create_record(1,i,key,value,table_ptr,params,metadata);
+	    }
+	    return -1;
+}
+//function for inserting tables with their respective columns
+int insert_table(config_params params,table_list *table_ptr) {
+	    //while loop for checking the right spot to insert Table
+	    int i; //this gives you the index inside params for looking at tables to be created
+	    //find the correct spot for inserting the table, this will be given by i
+	    for(i = 0; params.tablepara[i].table_name[0] && i < MAX_TABLES; i++) {
+	        //copy that name into the table_list struct
+	        strncpy(table_ptr->Table[i].table_name,params.tablepara[i].table_name,MAX_TABLE_LEN); 
+	    }
+	    
+	    //check for running out of memory
+	    if(i == MAX_TABLES)
+	        return -4;
+	    //everything worked fine
+	    else
+	        return 0;      
+}
+
+int record_query(char* tableName, char* predicates, int max_keys, char* keys_found, table_list* list)
+{
+    int ColumnName = 0;
+    bool foundtable = find_table(tableName, list);
+    if(foundtable)//if table exists
+    {
+        int foundkeys=0;
+        int i;
+        char *temp = NULL;
+        char columnName[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];//stores name
+        memset(columnName,0,sizeof(columnName));
+        char columnOp[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];//stores operator
+        memset(columnOp,0,sizeof(columnOp));
+        char columnVal[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];//stores value
+        memset(columnVal,0,sizeof(columnVal));
+        int columnValType[MAX_COLUMNS_PER_TABLE];//stores type of value
+        memset(columnValType,0,sizeof(columnValType));
+        temp = strtok(predicates, " ,");
+        for(i=0;i<10;i++)
         {
-            return false;
+                int counter = 1;//reset counter
+                while(temp != NULL && counter < 4)
+                {
+                        if(counter == 1)
+                        {//means temp contains column name
+                                strcpy(columnName[i], temp);
+                                temp = strtok(NULL, " ,");
+                                counter++;
+                        }
+                        else if(counter == 2)
+                        {//means temp contains operator
+                                strcpy(columnOp[i], temp);
+                                temp = strtok(NULL, ",");
+                                counter++;
+                        }
+                        else if(counter == 3)
+                        {//means temp contains column value
+                                bool isNumber = is_number(temp);//check if int or string
+                                if(isNumber)
+                                {
+                                        columnValType[i] = -1;
+                                }
+                                else if(!isNumber)
+                                {
+                                        columnValType[i] = strlen(temp);
+                                }
+                                strcpy(columnVal[i], temp);
+                                temp = strtok(NULL, " ,");
+                                counter++;
+                        }
+                }//finished 1 predicate, reset counter
+        }//end of interpreting predicate, have all values
+
+        bool found = false;
+        record_struct* pointer = NULL; //returns pointer to right table
+        //integer which holds the current index location while traversing through table_ptr
+        int a;
+        for(a = 0; list->Table[a].table_name[0] != 0 && i < MAX_TABLES; a++) {
+            //check whether we are at the correct spot by looking at table names
+            if(!strcmp(list->Table[a].table_name,tableName)) {
+                //table found
+                found = true;
+                break;
+            }
         }
-        else if(!strcmp(tmp_ptr_list1->key,key)) {//for the case where the node to be deleted is at the beggining
-                    table[index] = tmp_ptr_list1->next;
-                    free(tmp_ptr_list1);
-                    tmp_ptr_list1 = NULL;
-                    //record deleted, return true
-                    return true;
-        }     
-        else //one of the three cases for deletion 
+        if(!found)
+            return -3;
+        int j;
+        //check for columns
+        int k;
+        int l;
+        for(j=0;j<1000;j++)
         {
-            while(tmp_ptr_list1) {
-            
-                if(!strcmp(tmp_ptr_list1->key,key))  {//delete the current record_element
-                    tmp_ptr_list2->next = tmp_ptr_list1->next;
-                    free(tmp_ptr_list1);
-                    tmp_ptr_list1 = NULL;
-                    //record deleted, return true
-                    return true;
-                         }
-                //keep going through the array
-                else tmp_ptr_list2 = tmp_ptr_list1;
-                     tmp_ptr_list1 = tmp_ptr_list1->next;  
-                 }
-                 //city not found
-                 return false;
+            pointer = list->Table[a].RecordStruct[j];//pointer to records in j
+            if(pointer != NULL)//if not empty record go inside
+            {
+                record_struct* copypointer = pointer;
+                
+                while(copypointer != NULL)//check for end of array
+                {
+
+                    bool isFound = false;
+                    for(k=0; k<10 && copypointer->column.column_name[k][0] != '\0';k++)//loop to go to each column name in data
+                    {
+                            for(l=0;l<10;l++)//loop to go through each column name in predicates
+                            {
+                                if(columnName[l][0] != '\0')//if column name in predicate is not empty
+                                {
+                                    if(!strcmp(copypointer->column.column_name[k],columnName[l]))//if the name is equal
+                                    {
+                                        ColumnName++;
+                                        if(columnValType[l] == -1 && copypointer->column.type[k] == -1)//then its an int
+                                        {                                            
+                                            if(columnOp[l][0] == '=')
+                                            {
+                                                int temp1 = atoi(copypointer->column.value[k]);
+                                                int temp2 = atoi(columnVal[l]);
+                                                if(temp1 == temp2)
+                                                isFound = true;
+                                                else {
+							isFound = false;
+							goto end;}
+                                            }
+                                            else if(columnOp[l][0] == '>')
+                                            {
+                                                int temp1 = atoi(copypointer->column.value[k]);
+                                                int temp2 = atoi(columnVal[l]);
+                                                if(temp1 > temp2)
+                                                isFound = true;
+                                                else {
+							isFound = false;
+							goto end;}
+                                            }
+                                            else if(columnOp[l][0] == '<')
+                                            {
+                                                
+                                                int temp1 = atoi(copypointer->column.value[k]);
+                                                int temp2 = atoi(columnVal[l]);
+                                                if(temp1 < temp2)
+                                                isFound = true;
+                                               else {
+							isFound = false;
+							goto end;}
+                                            }
+                                            else return -4;
+                                        }
+                                        else if(columnValType[l] > -1 && copypointer->column.type[k] > -1)
+                                        {
+                                            if(columnOp[l][0] == '=')
+                                            {
+                                                if(!strcmp(copypointer->column.value[k],columnVal[l]))
+                                                isFound = true;
+                                                else {
+							isFound = false;
+							goto end;}
+                                            }
+                                            else return -4;
+                                        }
+                                }
+                            }
+                        }
+                    }//finish checking for each column of a key, if still true
+		end:                    
+                    if (isFound) {
+                                if(ColumnName == 0)
+                                     return -4;
+                                else
+                                {
+                                                        foundkeys++;
+                                                        if(foundkeys < max_keys && foundkeys == 1)
+                                                        {
+                                                            strcat(keys_found, copypointer->key);
+                                                        }
+                                                        else if(foundkeys <= max_keys)
+                                                        {
+                                                            strcat(keys_found, ",");
+                                                            strcat(keys_found, copypointer->key);
+                                                        }
+
+                                }
+                    }
+                    copypointer = copypointer->next;
+                }
+            }//done checking this recordstruct array, go to next
         }
-}	
+        return foundkeys;
+        
+    }
+    return -3;
+   
+   
+   
+}
 
+/**
+ * @brief Function that determines whether a character is alphanumeric character or not by using ASCII values.
+ * @param str_ptr The character that's being evaluated.
+ * @ret If the character is alphanumeric, return true. If not, return false.
+ */
+bool is_alpha(char str_ptr) {
 
+    int i = (int)(str_ptr);
+    if(((i >= 48) && (i <= 57)) || ((i >= 65) && (i <= 90)) || ((i >= 97) && (i <= 122)))
+        return true;
+    else return false;
+
+}
+/**
+ * @brief Keep sending the contents of the buffer until complete.
+ * @param sock Connection socket
+ * @param buf String buffer
+ * @param len Length of buffer
+ * @return Return 0 on success, -1 otherwise.
+ *
+ * The parameters mimic the send() function.
+ */
 int sendall(const int sock, const char *buf, const size_t len)
 {
 	size_t tosend = len;
 	while (tosend > 0) {
 		ssize_t bytes = send(sock, buf, tosend, 0);
 		if (bytes <= 0) 
-			break; // send() was not successful, so stop.
+			break; /// send() was not successful, so stop.
 		tosend -= (size_t) bytes;
 		buf += bytes;
 	};
@@ -170,6 +576,11 @@
 }
 
 /**
+ * @brief Reads the stream one byte at a time.
+ * @param sock Connection socket
+ * @param buf String buffer
+ * @param buflen Length of buffer
+ * @return Return 0 on success, -1 otherwise.
  * In order to avoid reading more than a line from the stream,
  * this function only reads one byte at a time.  This is very
  * inefficient, and you are free to optimize it or implement your
@@ -177,52 +588,54 @@
  */
 int recvline(const int sock, char *buf, const size_t buflen)
 {
-	int status = 0; // Return status.
+	int status = 0; /// Return status.
 	size_t bufleft = buflen;
 
 	while (bufleft > 1) {
-		// Read one byte from scoket.
+		/// Read one byte from scoket.
 		ssize_t bytes = recv(sock, buf, 1, 0);
 		if (bytes <= 0) {
-			// recv() was not successful, so stop.
+			/// recv() was not successful, so stop.
 			status = -1;
 			break;
 		} else if (*buf == '\n') {
-			// Found end of line, so stop.
+			/// Found end of line, so stop.
 			*buf = 0; // Replace end of line with a null terminator.
 			status = 0;
 			break;
 		} else {
-			// Keep going.
+			/// Keep going.
 			bufleft -= 1;
 			buf += 1;
 		}
 	}
-	*buf = 0; // add null terminator in case it's not already there.
+	*buf = 0; /// add null terminator in case it's not already there.
 
 	return status;
 }
 
-
 /**
- * @brief Parse and process a line in the config file.
+ * @brief Read and load configuration parameters.
+ *
+ * @param line Line of input read from file.
+ * @param params The structure where config parameters are loaded.
+ * @return Return 0 on success, -1 otherwise.
  */
 int process_config_line(char *line, struct config_params *params)
-{
-	// Commented lines ignored.
+{	
+	/// Commented lines ignored.
 	if (line[0] == CONFIG_COMMENT_CHAR || line[0] == '\n')
 		return 0;
-
-	// Extract config parameter name and value.
+	/// Extract config parameter name and value.
 	char name[MAX_CONFIG_LINE_LEN];
 	char value[MAX_CONFIG_LINE_LEN];
 	int items = sscanf(line, "%s %s\n", name, value);
 
-	// Line wasn't as expected.
+	/// Line wasn't as expected.
 	if (items != 2)
 		return -1;
 
-	// Process this line.
+	/// Process this line.
 	if (strcmp(name, "server_host") == 0) 
 	{
 		if (params->server_host[0] != NULL)
@@ -243,20 +656,36 @@
 		params->server_port = atoi(value);
 	}
 	
+	else if (strcmp(name, "concurrency") == 0) 
+	{
+		
+		if (params->concurrency != -1)
+		{
+			params->duplicateparam = true;
+			return -1;
+		}
+		if (!strcmp(value, "0") || !strcmp(value, "1") || !strcmp(value, "2") || !strcmp(value, "3"))
+		{
+			params->concurrency = atoi(value);
+			return 0;
+		}
+		else
+			return -1;
+	}	
+	
 	else if (strcmp(name, "username") == 0) 
 	{
 		if (params->username[0] != NULL)
-		{
+		{	
 			params->duplicateparam = true;
 			return -1;
 		}
 		strncpy(params->username, value, sizeof params->username);
 	} 
-	
 	else if (strcmp(name, "password") == 0) 
 	{
-		if (params->pass_[0] != NULL)
-		{
+		if (params->pass_[0] != '\0')
+		{	
 			params->duplicateparam = true;
 			return -1;
 		}
@@ -266,52 +695,416 @@
 	else if (strcmp(name, "table") == 0)
 	{
 		int i;
-		for (i = 0; i< MAX_TABLES; i++)
+		int columncount = 0;
+		
+		//checking whether table name is alphanumeric
+		int tn;
+		for (tn = 0; tn< strlen(value); tn++)
 		{
-	
-			if (params->table[i][0] == NULL)
+			int tnv = (int)(value[tn]);
+			if(((tnv >= 48) && (tnv <= 57)) || ((tnv >= 65) && (tnv <= 90)) || ((tnv >= 97) && (tnv <= 122)))
+					;
+			else
 			{
+			printf("\nError: Invalid parameters in configuration file.\n");
+			return -1;
+			}
+		}
+		
+		
+		for (i = 0; i< MAX_TABLES; i++) //checking whether there're duplicate tables
+				{	
+					if (params->table_name[i][0] == '\0') //found empty space
+						break;
+					
+					
+					if (strcmp(value, params->table_name[i]) == 0) ///if duplicate table name already exists
+					{
+						params->duplicatetable = true;
+						return -1;
+					}
+				}
+		
+		//if there're no duplicate tables and valid, start storing them
+		strncpy(params->table_name[i], value, MAX_TABLE_LEN );
+		strncpy(params->tablepara[i].table_name, value, MAX_TABLE_LEN );
+		//printf("Table name stored is %s\n", params->tablepara[i].table_name);
+		
+		//looping through to count number of commas
+		int cc;
+		int commacount = 0;
+		for(cc = 0; (line[cc]!= '\n'); cc++ )
+		{
+			int ccv = (int)(line[cc]);
+			if (ccv == 44)
+				commacount++;
+		}
+		//printf("Comma count is %d\n", commacount);		
+		
+		//moving onto getting table schema
+		char *token, *token_end;
+		
+		token = strtok_r(line, " \n", &token_end ); //first token is table
+		//printf("%s1\n", token);
+		int tokencount = 1;
+		
+		token = strtok_r(NULL, " \n", &token_end ); //second token is table name
+		//printf("%s2\n", token);
+		tokencount++;
+		
+		char*token_endcopy = (char *)malloc (strlen(token_end)+1); //this is the unparsed string with newline character that contains column pairs
+		strcpy(token_endcopy, token_end);
+		
+		token = strtok_r(NULL, " \n", &token_end ); //this is just to check whether the table has a schema
+		if (token == NULL && tokencount == 2)
+		{
+			printf("\nError: Missing parameters in the configuration file.\n");
+				return -1;
+		}
+		
+		char *tokenA, *tokenA_end;
+		tokenA = strtok_r(token_endcopy, ",\n", &tokenA_end ); //token A is the first pair of table column and type, definitely not NULL
+		tokencount++; //token count is now 3 with the first pair
+		//printf("%s3\n", tokenA);
+		
+		//Beginning of parsing the first pair of column
+		char *tokenB, *tokenB_end;
+		tokenB = strtok_r(tokenA, " \n", &tokenB_end); //Cutting out white spaces
+		//printf("%s4\n", tokenB);
+		
+		char*tokenBcopy = (char *)malloc (strlen(tokenB)+1);
+		strcpy (tokenBcopy, tokenB);				
+						
+		tokenB = strtok_r(NULL, " \n", &tokenB_end);
+						
+		if (tokenB == NULL) //Meaning there's no spaces within the column name and type pair
+		{					
+				//Cutting away between column name and type. Also check for extra or missing commas
+				char *tokenC, *tokenC_end;
+				tokenC = strtok_r(tokenBcopy, ":\n", &tokenC_end); //This should be the first column name
+				//printf("%s5\n", tokenC);
+				int tokenCcount = 1; //Gonna make sure there're only two tokens in one pair
+												
+				//Check for duplicate column names
+				int ka;
+				for (ka = 0; ka < MAX_COLUMNS_PER_TABLE; ka++)
+				{
+				if (params->tablepara[i].table_columns[ka][0] == '\0')
+					break;
+				if (strcmp(tokenC, params->tablepara[i].table_columns[ka]) == 0) ///if duplicate column name already exists
+					{
+						printf("\nError: Duplicate table column names in configuration file.\n");
+							return -1;
+					}	
+				}
+							
+				//Check whether column name is alphanumeric
+				int alp;
+				for (alp = 0; alp< strlen(tokenC); alp++)
+				{
+					int alpv = (int)(tokenC[alp]);
+					if(((alpv >= 48) && (alpv <= 57)) || ((alpv >= 65) && (alpv <= 90)) || ((alpv >= 97) && (alpv <= 122)))
+						;
+					else
+					{
+						printf("\nError: Invalid parameters in configuration file.\n");
+							return -1;
+					}
+				}		
+							
+				//If there're no errors, store column name
+				strncpy(params->tablepara[i].table_columns[columncount], tokenC, MAX_COLNAME_LEN);					
+				//printf("%s6\n", params->tablepara[i].table_columns[columncount]);
+				
+				//Continue on to next part of the string which is column type of the first pair
+				while (tokenC != NULL)
+				{
+					tokenC = strtok_r(NULL, ":\n", &tokenC_end); //This should be the column type
+						if(tokenC == NULL)
+							break;
+								
+						//Check whether it's an int or char type or neither							
+						if (strcmp(tokenC, "int") == 0) //type is an int
+						{
+							params->tablepara[i].column_types[columncount] = -1;
+							columncount++;
+							//printf("Type stored is %d.\n", params->tablepara[i].column_types[columncount]);
+						}
+						
+						else if (strncmp(tokenC,"char[",5) == 0) //type is a char[n] 
+						{
+							int charvalA;
+							char* tokencopy;
+							tokencopy = (char *)malloc (strlen(tokenC)+1);
+							strcpy (tokencopy, tokenC);
+							
+							//separating integer from char[n]
+							char tempnumberstr[10];
+														
+							int a1;
+							int jk = 0;
+							for(a1 = 0; (tokencopy[a1]!= ']'); a1++ )
+							{
+								if(tokencopy[a1] == '[')
+								{
+									a1++;
+									while (tokencopy[a1] == ' ')
+										a1++;
+									break;
+								}					
+							}
+							
+							int k1;
+							for (k1 = a1; (tokencopy[k1]!= ']'); k1++ )
+							{	
+								int tv = (int)(tokencopy[k1]);
+								if (((tv >= 48) && (tv <= 57)) || (tv == 43) || (tv == 45)) //is a number or plus minus sign
+								{
+									tempnumberstr[jk]= tokencopy[k1];
+									jk++;
+								}	
+								else
+								{
+									printf("\nError: Invalid parameters in configuration file.\n");
+										return -1;
+								}
+							}
+							jk++;
+							tempnumberstr[jk]= '\0';
+							charvalA = atoi(tempnumberstr);
+							
+							if (charvalA<=0) //if the size of the array is negative or zero size array
+							{
+								printf("\nError: Invalid parameters in configuration file.\n");
+									return -1;	
+							}
+							//Storing column type
+							params->tablepara[i].column_types[columncount]= charvalA;
+							//printf("Type stored is %d.\n", params->tablepara[i].column_types[columncount]);
+							columncount++;
+							free(tokencopy);
+						}					
+						else //Wrong column type or no column type
+						{
+							printf("\nError: Invaid parameters in the configuration file.\n");
+									return -1;
+						}
+						tokenCcount++;
+						}
+					if (tokenCcount != 2) //Accounting for invalid commas, dividing up name and type
+					{
+						printf("\nError: Invaid format in the configuration file.\n");
+							return -1;
+					} 
+			}
+						
+			if (tokenB != NULL) //If spaces exist between colons or in names and types
+			{
+				printf("\nError: Invaid format in the configuration file.\n");
+				return -1;
+			}			
+		//End of parsing first pair of column name and type
+		
+		//Moving onto next pairs of column names and types
+		//tokenA_end is where the rest of the string exists
+		///////////////////////////////////////////////////////////////////
+		while (tokenA != NULL)
+		{
+			char *token2, *token2_end;
+			tokenA = strtok_r(NULL, ",\n", &tokenA_end); //tokenA = pairs of column names
+			
+			if (tokenA == NULL)
 				break;
+			tokencount++; //tokencount is incremented everytime there's a new pair
+			//printf("%s7\n", tokenA);
+			
+			//Cutting out white spaces in name and type column pairs
+			token2 = strtok_r(tokenA, " \n", &token2_end);
+			char*token2copy = (char *)malloc (strlen(token)+1);
+			strcpy(token2copy, token2);				
+							
+			token2 = strtok_r(NULL, " \n", &token2_end);
+			
+			if(token2 == NULL) //No weird white spaces in column pair
+			{
+				//Cutting away between column name and type. Also check for extra or missing commas
+				char *token3, *token3_end;
+				token3 = strtok_r(token2copy, ":\n", &token3_end); //This should be the column name
+				//printf("%s8\n", token3);
+				int token3count = 1; //Gonna make sure there're only two tokens in one pair
+																
+				//Check for duplicate column names
+				int k;
+				for (k = 0; k< MAX_COLUMNS_PER_TABLE; k++)
+				{
+					if (params->tablepara[i].table_columns[k][0] == '\0')
+								break;
+					if (strcmp(token3, params->tablepara[i].table_columns[k]) == 0) ///if duplicate column name already exists
+					{
+						printf("\nError: Duplicate table column names in configuration file.\n");
+									return -1;
+					}	
+				}
+											
+				//Check whether column name is alphanumeric
+				int al;
+				for (al = 0; al< strlen(token3); al++)
+				{
+					int alv = (int)(token3[al]);
+					if(((alv >= 48) && (alv <= 57)) || ((alv >= 65) && (alv <= 90)) || ((alv >= 97) && (alv <= 122)))
+						;
+					else
+					{
+						printf("\nError: Invalid parameters in configuration file.\n");
+								return -1;
+					}
+				}		
+											
+				//If there're no errors, store column name
+				strncpy(params->tablepara[i].table_columns[columncount], token3, MAX_COLNAME_LEN);					
+				//printf("%s9\n", params->tablepara[i].table_columns[columncount]);
+								
+				//Continue on to next part of the string which is the type
+				while (token3 != NULL)
+				{
+					token3 = strtok_r(NULL, ":\n", &token3_end); //This should be the column type
+
+					if(token3 == NULL)
+						break;
+												
+					//Check whether it's an int or char type or neither							
+					if (strcmp(token3, "int") == 0) //type is an int
+					{
+						params->tablepara[i].column_types[columncount] = -1;
+						columncount++;
+						//printf("Type stored is %d.\n", params->tablepara[i].column_types[columncount]);						
+					}
+										
+					else if (strncmp(token3,"char[",5) == 0) //type is a char[n] 
+					{
+						int charval;
+						char* token3copy;
+						token3copy = (char *)malloc (strlen(token3)+1);
+						strcpy (token3copy, token3);
+											
+						//separating integer from char[n]
+						char tempnumberstrA[10];
+																		
+						int a;
+						int j = 0;
+						for(a = 0; (token3copy[a]!= ']'); a++ )
+						{
+							if(token3copy[a] == '[')
+							{
+								a++;
+								while (token3copy[a] == ' ')
+									a++;
+								break;
+							}					
+						}
+											
+						int kk;
+						for (kk = a; (token3copy[kk]!= ']'); kk++ )
+						{	
+							int tn = (int)(token3copy[kk]);
+							if (((tn >= 48) && (tn <= 57)) || (tn == 43) || (tn == 45)) //is a number or plus minus sign
+							{
+								tempnumberstrA[j]= token3copy[kk];
+									j++;
+							}	
+							else
+							{
+								printf("\nError: Invalid parameters in configuration file.\n");
+									return -1;
+							}
+						}
+							j++;
+						tempnumberstrA[j]= '\0';
+						charval = atoi(tempnumberstrA);
+											
+						if (charval <= 0) //if the size of the array is negative or zero size array
+						{
+							printf("\nError: Invalid parameters in configuration file.\n");
+									return -1;	
+						}
+						//Storing column type
+						params->tablepara[i].column_types[columncount]= charval;
+						//printf("Type stored is %d.\n", params->tablepara[i].column_types[columncount]);
+							columncount++;
+							free(token3copy);
+					}			
+					
+					else //Wrong column type or no column type
+					{
+						printf("\nError: Invaid parameters in the configuration file.\n");
+							return -1;
+					}
+					token3count++;						
+					
+				}
+				if (token3count != 2) //Accounting for invalid commas, dividing up name and type
+				{
+					printf("\nError: Invaid format in the configuration file.\n");
+						return -1;
+				} 
 			}
 			
-			if (strcmp(value, params->table[i]) == 0) //if duplicate table name already exists
+			else if (token2 != NULL) //If spaces exist in between
 			{
-				params->duplicatetable = true;
-				return -1;
+				printf("\nError: Invaid format in the configuration file.\n");
+					return -1;
 			}
+			free(token2copy);
 		}
+		/////////////////////////////////////////////////////////////////////
 		
-		strncpy(params->table[i], value, MAX_TABLE_LEN );
+		//accounting for extra commas
+		//printf("Token count is %d and comma count is %d.\n", tokencount, commacount);
+		if (tokencount - commacount != 3)
+		{
+			printf("\nError: Invalid format in the configuration file.\n");
+				return -1;
+		}
 		
+		//freeing malloc memories
+		free(token_endcopy);
+		free(tokenBcopy);
 	}
 	
-	// else if (strcmp(name, "data_directory") == 0) 
-	//{
-	//	strncpy(params->data_directory, value, sizeof params->data_directory);
-	//} 
+	/// else if (strcmp(name, "data_directory") == 0) 
+	///{
+	///	strncpy(params->data_directory, value, sizeof params->data_directory);
+	///} 
 	
 	else  
 	{
-		return 0;// Ignore unknown config parameters.
+		return 0;/// Ignore unknown config parameters.
 	}
 
 	return 0;
 }
 
-
+/**
+ * @brief Read and load configuration parameters.
+ *
+ * @param config_file The name of the configuration file.
+ * @param params The structure where config parameters are loaded.
+ * @return Return 0 on success, -1 otherwise.
+ */
 int read_config(const char *config_file, struct config_params *params)
 {
+	
 	int error_occurred = 0;
 	params->duplicateparam = false;
 	params->duplicatetable = false;
-	// Open file for reading.
+	/// Open file for reading.
 	FILE* input;
 	input = fopen(config_file, "r");
 	
 	if (input == NULL)
 	{
 		
-	printf("Error: Unable to read configuration file.\n");
+	printf("\nError: Unable to read configuration file.\n");
 		error_occurred = 1;
 		errno = ERR_UNKNOWN;
 		return -1;		
@@ -319,55 +1112,100 @@
 
 	else
 	{
-	// Process the config file.
+	/// Process the config file.
 	while (!error_occurred && !feof(input)) 
 		{
-			// Read a line from the file.
+			/// Read a line from the file.
 			char line[MAX_CONFIG_LINE_LEN];
 			char *l = fgets(line, sizeof line, input);			
 			
-			if (l == line) //right size, proceed to process line
+			if (l == line) ///right size, proceed to process line
 			{
-				process_config_line(line, params);
+				int process = process_config_line(line, params);
 				
 				if (params->duplicateparam == true)
 				{
-					printf("Error: Duplicate parameters in configuration file.\n");
+					printf("\nError: Duplicate parameters in configuration file.\n");
 					error_occurred = 1;
 					return -1;
 				}
 				
 				if (params->duplicatetable == true)
 				{
-					printf("Error: Duplicate table names in configuration file.\n");
+					printf("\nError: Duplicate table names in configuration file.\n");
 					error_occurred = 1;
 					return -1;
 				}
+				
+				if (process == -1)
+				{
+					//printf("\nError: Invalid parameters in configuration file.\n");
+					error_occurred = 1;
+					return -1;
+				}
 					
 			}
 			
-			else if (!feof(input)) //not the right size
+			else if (!feof(input)) ///not the right size
 			{
-				printf("Error: Configuration file too large.\n");
+				printf("\nError: Configuration file too large.\n");
 				error_occurred = 1;
 				return -1;
 			}
 		}
-			
-			
-	if((params->server_host[0] == NULL) || (params->server_port == 0) || (params->username[0] == NULL) || (params->pass_[0] == NULL) || (params->table[0] == NULL))
+				
+	if((params->server_host[0] == NULL) || (params->concurrency == -1) || (params->server_port == 0) || (params->username[0] == NULL) || (params->pass_[0] == NULL) || (params->table_name[0][0] == '\0'))
 		{
-			printf("Error: Missing parameters in configuration file.\n");
+			printf("\nError: Missing parameters in configuration file.\n");
 			error_occurred = 1;
 			return -1;
 		}
 		
 	}
+	/*
+	//testing: printing out parameters
+	printf("%s\n", params->server_host);
+	printf("%d\n", params->server_port);
+	printf("%s\n", params->username);
+	printf("%s\n", params->pass_);
 	
+	int i;
+	for (i = 0; i< MAX_TABLES; i++)
+		{	
+			if (params->table_name[i][0] == '\0')
+				break;
+			
+			printf("%s\n", params->table_name[i]);
+		}
+	
+	int j, k;	
+	for (j = 0; j< MAX_TABLES; j++)
+		{
+			if (params->tablepara[j].table_name[0] == '\0')
+				break;
+				
+			printf("%s\n", params->tablepara[j].table_name);
+			for (k = 0; k< MAX_COLUMNS_PER_TABLE; k++)
+			{
+				if (params->tablepara[j].table_columns[k][0] == '\0')
+					break;
+				printf("%s\n", params->tablepara[j].table_columns[k]);
+				printf("%d\n", params->tablepara[j].column_types[k]);
+			}
+			
+		}
+	*/			
+			
 	fclose(input);
 	return 0;
 }
 
+/**
+ * @brief Generates a log message.
+ * 
+ * @param file The output stream
+ * @param message Message to log.
+ */
 void logger(FILE *file, char *message)
 {
 	if(!file)
@@ -375,7 +1213,14 @@
 	fprintf(file,"%s",message);
 	fflush(file);
 }
-
+/**
+ * @brief Generates an encrypted password string using salt CRYPT_SALT.
+ * 
+ * @param passwd Password before encryption.
+ * @param salt Salt used to encrypt the password. If NULL default value
+ * DEFAULT_CRYPT_SALT is used.
+ * @return Returns encrypted password.
+ */
 char *generate_encrypted_password(const char *passwd, const char *salt)
 {
 	if(salt != NULL)
@@ -384,3 +1229,561 @@
 		return crypt(passwd, DEFAULT_CRYPT_SALT);
 }
 
+/**
+ * @brief This is a function that parses the query command from client side to be used in server side
+ * 
+ * @param unparsed_ pointer to the unparsed string
+ * @param query_params *qparams pointer to the struct where query parameters are stored
+ * @return pointer to the parsed string
+ */
+char* query_parsing(char* unparsed_, struct query_params *qparams)
+{
+    char* unparsed = (char *)malloc (strlen(unparsed_)+1); 
+    strcpy(unparsed, unparsed_);
+    char *token, *token_end;
+    int columncount = 0;
+    
+    //looping through to count number of commas
+    int cc;
+    int commacount = 0;
+        for(cc = 0; (unparsed[cc]!= '\0'); cc++ )
+	{
+                int ccv = (int)(unparsed[cc]);
+		if (ccv == 44)
+			commacount++;
+	}     
+    
+    token = strtok_r(unparsed, ",\0", &token_end); //first predicate
+    //printf("%s1\n", token);
+    int tokencount = 1; //counting predicates
+    
+    if (token == NULL) //empty string
+        return NULL;
+    
+    //First predicate parsing starts here
+    //cutting out first predicate
+    char* tokencopy = (char *)malloc (strlen(token)+1); //first predicate full
+    strcpy(tokencopy, token);
+    
+    //column name parsing starts here
+    char *tokenA, *tokenA_end;
+    tokenA = strtok_r(tokencopy, "<=>", &tokenA_end); //column name
+    //printf("%s2\n", tokenA);
+    
+    //cutting white space for column name
+    char *tokenB, *tokenB_end;
+        tokenB = strtok_r(tokenA, " \0", &tokenB_end); //Cutting out white spaces
+	//printf("%s3\n", tokenB);
+		
+	char*tokenBcopy = (char *)malloc (strlen(tokenB)+1);
+	strcpy (tokenBcopy, tokenB);				
+						
+	tokenB = strtok_r(NULL, " \0", &tokenB_end); //Checking whether column name has spaces in it
+						
+	if (tokenB == NULL) //Meaning there's no spaces in column name
+        {
+           //check whether column name is alphanumeric
+            int alp;
+            for (alp = 0; alp< strlen(tokenBcopy); alp++)
+            {
+                    int alpv = (int)(tokenBcopy[alp]);
+                    if(((alpv >= 48) && (alpv <= 57)) || ((alpv >= 65) && (alpv <= 90)) || ((alpv >= 97) && (alpv <= 122)))
+                            ;
+                    else
+                        return NULL;
+            } 
+            //if it's okay, store the column name
+            strncpy (qparams->column_names[columncount], tokenBcopy, MAX_COLNAME_LEN); 
+            //printf("Column name stored is %s.\n", qparams->column_names[columncount]);
+        }
+        else if (tokenB != NULL) //there's white spaces in column name
+            return NULL;
+  
+    //column name parsing ends here
+        
+    //operator parsing starts here
+    //looping through to search for operators
+    int o;
+    int ocount = 0;
+    char operator;
+        for(o = 0; (token[o]!= '\0'); o++ )
+	{
+                int ov = (int)(token[o]);
+		if ((ov == 60) || (ov == 61) || (ov == 62))
+                {
+                    operator = token[o];
+		    ocount++;
+                }
+	}    
+    if (ocount == 0)
+        return NULL;
+    if (ocount != 1)
+        return NULL;
+    //if it's right store the operator
+    qparams->operator[columncount] = operator;
+    //printf("Operator stored is %c.\n", qparams->operator[columncount]);
+    //operator parsing ends here
+    
+    //value parsing starts here
+    //tokenA_end is the string after the operator
+    
+    //cutting out white spaces beginning and end and storing into a new string array
+    char valueA[MAX_VALUE_LEN]; 
+    memset(valueA,0,sizeof(valueA));
+    int p;
+    int alphacount = 0;
+    for (p= 0; (tokenA_end[p]!='\0'); p++) //cutting space in the beginning
+    {
+        int pv = (int)(tokenA_end[p]);
+        if (((pv >= 48) && (pv <= 57)) || ((pv >= 65) && (pv <= 90)) || ((pv >= 97) && (pv <= 122)) || (pv == 32) || (pv == 43) || (pv == 45)) //alphanumeric or plus minus
+        {
+            if ((pv != 32) && (alphacount == 0))//beginning alphanumeric
+            {
+                valueA[alphacount] = tokenA_end[p];
+                alphacount++;
+            }
+            else if(alphacount > 0)
+            {
+                valueA[alphacount] = tokenA_end[p];
+                alphacount++;
+            }
+        }
+        else //not alphanumeric
+                return NULL;
+     }
+    if (alphacount == 0)
+        return NULL;
+    
+    //printf("%shi\n", valueA);
+    char* value = valueA;
+    while (value[strlen(value)-1] == ' ')
+        value[strlen(value)-1] = '\0';
+    
+    //printf("lala%slala\n", value);
+    
+    //after parsing store the value
+    strncpy (qparams->value[columncount], value, MAX_VALUE_LEN); 
+    //printf("Value stored is %s.\n", qparams->value[columncount]);
+    //value parsing ends here
+    columncount++;
+    ///First predicate parsing ends here    
+    
+    ////////////////////////////////////////////////////////////////////
+    ///Next predicates parsing start here
+    //moving onto next predicates
+    while (token != NULL)
+    {
+        token = strtok_r(NULL, ",\0", &token_end); //full predicate
+        if (token == NULL)
+            break;
+        tokencount++;
+        //printf("%s4\n", token);
+        
+        char*tokenstar = (char *)malloc (strlen(token)+1); //full predicate that's not cut
+	strcpy (tokenstar, token);
+        
+        //column name parsing starts here
+        char *token1, *token1_end;
+        token1 = strtok_r(token, "<=>", &token1_end); //column name
+        //printf("%s5\n", token1);
+
+        //cutting white space for column name
+        char *token2, *token2_end;
+        token2 = strtok_r(token1, " \0", &token2_end); //Cutting out white spaces
+	//printf("%s6\n", token2);
+		
+	char*token2copy = (char *)malloc (strlen(token2)+1);
+	strcpy (token2copy, token2);				
+						
+	token2 = strtok_r(NULL, " \0", &token2_end); //Checking whether column name has spaces in it
+						
+	if (token2 == NULL) //Meaning there's no spaces in column name
+        {
+           //check whether column name is alphanumeric
+            int al;
+            for (al = 0; al< strlen(token2copy); al++)
+            {
+                    int alv = (int)(token2copy[al]);
+                    if(((alv >= 48) && (alv <= 57)) || ((alv >= 65) && (alv <= 90)) || ((alv >= 97) && (alv <= 122)))
+                            ;
+                    else
+                        return NULL;
+            } 
+            //if it's okay, store the column name
+            strncpy (qparams->column_names[columncount], token2copy, MAX_COLNAME_LEN); 
+            //printf("Column name stored is %s.\n", qparams->column_names[columncount]);
+        }
+        else if (token2 != NULL) //there's white spaces in column name
+            return NULL;
+   
+    //column name parsing ends here
+        
+    //operator parsing starts here
+    //looping through to search for operators
+       
+    int op;
+    int ocountt = 0;
+    char operatorr;
+        for(op = 0; (tokenstar[op]!= '\0'); op++ )
+	{
+                int ovv = (int)(tokenstar[op]);
+		if ((ovv == 60) || (ovv == 61) || (ovv == 62))
+                {
+                    operatorr = tokenstar[op];
+		    ocountt++;
+                }
+	}    
+    if (ocountt == 0)
+        return NULL;
+    if (ocountt != 1)
+        return NULL;
+    //if it's right store the operator
+    qparams->operator[columncount] = operatorr;
+    //printf("Operator stored is %c.\n", qparams->operator[columncount]);
+    //operator parsing ends here
+    
+    //value parsing starts here
+    //token1_end is the string after the operator
+    
+    //cutting out white spaces beginning and end and storing into a new string array
+    char valueB[MAX_VALUE_LEN];    
+    int pk;
+    int alphacount2 = 0;
+    for (pk= 0; (token1_end[pk]!='\0'); pk++) //cutting space in the beginning
+    {
+        int pkv = (int)(token1_end[pk]);
+        if (((pkv >= 48) && (pkv <= 57)) || ((pkv >= 65) && (pkv <= 90)) || ((pkv >= 97) && (pkv <= 122)) || (pkv == 32) || (pkv == 43) || (pkv == 45)) //alphanumeric or plus minus
+        {
+            if ((pkv != 32) && (alphacount2 == 0))//beginning alphanumeric
+            {
+                valueB[alphacount2] = token1_end[pk];
+                alphacount2++;
+            }
+            else if(alphacount2 > 0)
+            {
+                valueB[alphacount2] = token1_end[pk];
+                alphacount2++;
+            }
+        }
+        else //not alphanumeric
+                return NULL;
+     }
+    if (alphacount2 == 0)
+        return NULL;
+    
+    //printf("%shi\n", valueB);
+    char* value2 = valueB;
+    while (value2[strlen(value2)-1] == ' ')
+        value2[strlen(value2)-1] = '\0';
+    
+    //printf("lala%slala\n", value2);
+    
+    //after parsing store the value
+    strncpy (qparams->value[columncount], value2, MAX_VALUE_LEN); 
+    //printf("Value stored is %s.\n", qparams->value[columncount]);
+    //value parsing ends here
+    columncount++;
+    ///predicate parsing ends here
+  
+    free(tokenstar);
+    free(token2copy);   
+    }
+    ///////////////////////////////////////////////////////////////////
+    ///Next predicates parsing end here
+    
+    //if the commas don't match up the number of predicates
+    if ((tokencount - commacount) != 1)
+        return NULL;
+    //free malloc memories
+    free(tokencopy);
+    free(tokenBcopy);
+    free(unparsed);
+    
+    /////////////////////////////////////////////////////////////////
+    ///Putting it together in a string
+    char big[3000];
+    char* bigs = big;
+    char* space = " ";
+    char* comma = ",";
+    
+    int b;
+    for (b = 0; b < MAX_COLUMNS_PER_TABLE; b++)
+    {
+        if (qparams->column_names[b][0] == '\0')
+            break;
+        
+        char* column_name = qparams->column_names[b];
+                strcat(bigs, column_name);
+                strcat(bigs, space);
+                
+                strncat (bigs, &(qparams->operator[b]), 1);
+                strcat(bigs, space);
+                
+        char* value = qparams->value[b];
+                strcat(bigs, value);
+                strcat(bigs, comma);       
+    }
+    bigs[strlen(bigs)-1] = '\0';    
+    
+    //printf("%shi\n", bigs);
+    
+    char* parsed = bigs;
+    return parsed;
+}
+
+/**
+ * @brief This is a function that parses the set command from client side to be used in server side
+ * 
+ * @param unparsed_ pointer to the unparsed string
+ * @param set_params *sparams pointer to the struct where set parameters are stored
+ * @return pointer to the parsed string
+ */
+char* set_parsing(char* unparsed_, struct set_params *sparams)
+{
+    char* unparsed = (char *)malloc (strlen(unparsed_)+1); 
+    strcpy(unparsed, unparsed_);
+    char *token, *token_end;
+    int columncount = 0;
+    
+    //looping through to count number of commas
+    int cc;
+    int commacount = 0;
+        for(cc = 0; (unparsed[cc]!= '\0'); cc++ )
+	{
+                int ccv = (int)(unparsed[cc]);
+		if (ccv == 44)
+			commacount++;
+	}     
+    
+    token = strtok_r(unparsed, ",\0", &token_end); //first predicate
+    //printf("%s1\n", token);
+    int tokencount = 1; //counting predicates
+    
+    if (token == NULL) //empty string
+        return NULL;
+    
+    //First predicate parsing starts here
+    //cutting out first predicate
+    char* tokencopy = (char *)malloc (strlen(token)+1); //first predicate full
+    strcpy(tokencopy, token);
+    
+    //column name parsing starts here
+    char *tokenA, *tokenA_end;
+    tokenA = strtok_r(tokencopy, " \0", &tokenA_end); //column name
+    //printf("%s2\n", tokenA);
+    
+    //cutting white space for column name
+    char *tokenB, *tokenB_end;
+        tokenB = strtok_r(tokenA, " \0", &tokenB_end); //Cutting out white spaces
+	//printf("%s3\n", tokenB);
+		
+	char*tokenBcopy = (char *)malloc (strlen(tokenB)+1);
+	strcpy (tokenBcopy, tokenB);				
+						
+	tokenB = strtok_r(NULL, " \0", &tokenB_end); //Checking whether column name has spaces in it
+						
+	if (tokenB == NULL) //Meaning there's no spaces in column name
+        {
+           //check whether column name is alphanumeric
+            int alp;
+            for (alp = 0; alp< strlen(tokenBcopy); alp++)
+            {
+                    int alpv = (int)(tokenBcopy[alp]);
+                    if(((alpv >= 48) && (alpv <= 57)) || ((alpv >= 65) && (alpv <= 90)) || ((alpv >= 97) && (alpv <= 122)))
+                            ;
+                    else
+                        return NULL;
+            } 
+            //if it's okay, store the column name
+            strncpy (sparams->column_names[columncount], tokenBcopy, MAX_COLNAME_LEN); 
+            //printf("Column name stored is %s.\n", qparams->column_names[columncount]);
+        }
+        else if (tokenB != NULL) //there's white spaces in column name
+            return NULL;
+  
+    //column name parsing ends here
+    
+    //value parsing starts here
+    //tokenA_end is the string after the operator
+    
+    //cutting out white spaces beginning and end and storing into a new string array
+    char valueA[MAX_VALUE_LEN]; 
+    memset(valueA,0,sizeof(valueA));
+    int p;
+    int alphacount = 0;
+    for (p= 0; (tokenA_end[p]!='\0'); p++) //cutting space in the beginning
+    {
+        int pv = (int)(tokenA_end[p]);
+        if (((pv >= 48) && (pv <= 57)) || ((pv >= 65) && (pv <= 90)) || ((pv >= 97) && (pv <= 122)) || (pv == 32) || (pv == 43) || (pv == 45)) //alphanumeric or plus minus
+        {
+            if ((pv != 32) && (alphacount == 0))//beginning alphanumeric
+            {
+                valueA[alphacount] = tokenA_end[p];
+                alphacount++;
+            }
+            else if(alphacount > 0)
+            {
+                valueA[alphacount] = tokenA_end[p];
+                alphacount++;
+            }
+        }
+        else //not alphanumeric
+                return NULL;
+     }
+    if (alphacount == 0)
+        return NULL;
+    
+    //printf("%shi\n", valueA);
+    char* value = valueA;
+    while (value[strlen(value)-1] == ' ')
+        value[strlen(value)-1] = '\0';
+    
+    //printf("lala%slala\n", value);
+    
+    //after parsing store the value
+    strncpy (sparams->value[columncount], value, MAX_VALUE_LEN); 
+    //printf("Value stored is %s.\n", qparams->value[columncount]);
+    //value parsing ends here
+    columncount++;
+    ///First predicate parsing ends here    
+    
+    ////////////////////////////////////////////////////////////////////
+    ///Next predicates parsing start here
+    //moving onto next predicates
+    
+    while (token != NULL)
+    {
+        token = strtok_r(NULL, ",\0", &token_end); //full predicate
+        if (token == NULL)
+            break;
+        tokencount++;
+        //printf("%s4\n", token);
+        
+        char*tokenstar = (char *)malloc (strlen(token)+1); //full predicate that's not cut
+	strcpy (tokenstar, token);
+        
+        //column name parsing starts here
+        char *token1, *token1_end;
+        token1 = strtok_r(token, " \0", &token1_end); //column name
+        //printf("%s5\n", token1);
+
+        //cutting white space for column name
+        char *token2, *token2_end;
+        token2 = strtok_r(token1, " \0", &token2_end); //Cutting out white spaces
+	//printf("%s6\n", token2);
+		
+	char*token2copy = (char *)malloc (strlen(token2)+1);
+	strcpy (token2copy, token2);				
+						
+	token2 = strtok_r(NULL, " \0", &token2_end); //Checking whether column name has spaces in it
+						
+	if (token2 == NULL) //Meaning there's no spaces in column name
+        {
+           //check whether column name is alphanumeric
+            int al;
+            for (al = 0; al< strlen(token2copy); al++)
+            {
+                    int alv = (int)(token2copy[al]);
+                    if(((alv >= 48) && (alv <= 57)) || ((alv >= 65) && (alv <= 90)) || ((alv >= 97) && (alv <= 122)))
+                            ;
+                    else
+                        return NULL;
+            } 
+            //if it's okay, store the column name
+            strncpy (sparams->column_names[columncount], token2copy, MAX_COLNAME_LEN); 
+            //printf("Column name stored is %s.\n", qparams->column_names[columncount]);
+        }
+        else if (token2 != NULL) //there's white spaces in column name
+            return NULL;
+    
+    //value parsing starts here
+    //token1_end is the string after the operator
+    
+    //cutting out white spaces beginning and end and storing into a new string array
+    char valueB[MAX_VALUE_LEN]; 
+    memset(valueB,0,sizeof(valueB));
+    int pk;
+    int alphacount2 = 0;
+    for (pk= 0; (token1_end[pk]!='\0'); pk++) //cutting space in the beginning
+    {
+        int pkv = (int)(token1_end[pk]);
+        if (((pkv >= 48) && (pkv <= 57)) || ((pkv >= 65) && (pkv <= 90)) || ((pkv >= 97) && (pkv <= 122)) || (pkv == 32) || (pkv == 43) || (pkv == 45)) //alphanumeric or plus minus
+        {
+            if ((pkv != 32) && (alphacount2 == 0))//beginning alphanumeric
+            {
+                valueB[alphacount2] = token1_end[pk];
+                alphacount2++;
+            }
+            else if(alphacount2 > 0)
+            {
+                valueB[alphacount2] = token1_end[pk];
+                alphacount2++;
+            }
+        }
+        else //not alphanumeric
+                return NULL;
+     }
+    if (alphacount2 == 0)
+        return NULL;
+    
+    //printf("%shi\n", valueB);
+    char* value2 = valueB;
+    while (value2[strlen(value2)-1] == ' ')
+        value2[strlen(value2)-1] = '\0';
+    
+    //printf("lala%slala\n", value2);
+    
+    //after parsing store the value
+    strncpy (sparams->value[columncount], value2, MAX_VALUE_LEN); 
+    //printf("Value stored is %s.\n", qparams->value[columncount]);
+    //value parsing ends here
+    columncount++;
+    ///predicate parsing ends here
+  
+    free(tokenstar);
+    free(token2copy);   
+    }
+    ///////////////////////////////////////////////////////////////////
+    ///Next predicates parsing end here
+    
+    //if the commas don't match up the number of predicates
+    if ((tokencount - commacount) != 1)
+        return NULL;
+    //free malloc memories
+    free(tokencopy);
+    free(tokenBcopy);
+    free(unparsed);
+    
+    /////////////////////////////////////////////////////////////////
+    ///Putting it together in a string
+    char big[3000];
+    memset(big,0,sizeof(big));
+    char* bigs = big;
+    char* space = " ";
+    char* comma = ",";
+    
+    int b;
+    for (b = 0; b < MAX_COLUMNS_PER_TABLE; b++)
+    {
+        if (sparams->column_names[b][0] == '\0')
+            break;
+        
+        char* column_name = sparams->column_names[b];
+                strcat(bigs, column_name);
+                strcat(bigs, space);
+                
+        char* value = sparams->value[b];
+                strcat(bigs, value);
+                strcat(bigs, comma);       
+    }
+    bigs[strlen(bigs)-1] = '\0';  
+    
+    //printf("%shi\n", bigs);
+    
+    char* parsed = bigs;
+    return parsed;
+}
+
+
+
+
Index: storage.c
===================================================================
--- storage.c	(revision 1)
+++ storage.c	(revision 66)
@@ -1,8 +1,8 @@
-/**
+/*
  * @file
  * @brief This file contains the implementation of the storage server
  * interface as specified in storage.h.
- */
+ */ 
 
 #include <errno.h>
 #include <stdlib.h>
@@ -15,9 +15,65 @@
 #include "storage.h"
 #include "utils.h"
 #define LOGGING 0
+#include <math.h>
+/**
+ * @brief variable which stores current client info
+ */
+bool client_info[2] = {false};
+/**
+ * @brief Function that parses whether an input adheres to the alphanumeric and size rules specified.
+ * @param no_cmd This determines whether only alphanumeric values are to be accepted or whether space is accepted too. 1 accepts only alphanumerics and 2 accepts both alphanumerics and space.
+ * @param size This is what the size of input should be.
+ * @param ptr This points to the string that is being evaluated.
+ * @ret If the character is alphanumeric and/or space (according to the command number), return true. If not, return false. Also, if the size of the input is greater than the size speficied for the value, return false.
+ */
+bool client_parser(int no_cmd, int size, char* ptr) {
 
+        int i;
+         //only alphanumeric characters allowed
+        if(no_cmd == 1) {
+            for(i = 0;(ptr[i] != '\0') ; i++) {
+                if(!is_alpha(ptr[i]))
+                return false;
+            }
 
+            if(size < (i))
+                    return false;
+        }
+        else if(no_cmd == 2) {
+                for(i = 0;(ptr[i] != '\0'); i++) {
+                    if(!is_alpha(ptr[i]) && !(ptr[i] == ' '))
+                    return false;
+                }
+                if(size <= (i))
+                    return false;
+                return true;
+        }
+        
+        return true;
+}
 /**
+ * @brief Function that parses valid alphanumeric values and takes out invalid characters.
+ * @param str Pointer pointing to the input string which might contain invalid characters.
+ * @ret The function returns the pointer to the new character array which contains the parsed input.
+ */
+char*  parser_string (char *str) {
+    
+    char *tmp_ptr = malloc(sizeof(char)*(100));
+    int i;
+    int k = 0;
+    for(i = 0; str[i] && (i < MAX_KEY_LEN); i ++) {
+    
+        if(is_alpha(str[i])) {
+            tmp_ptr[k] = str[i];
+            k++;
+        }
+    }
+    tmp_ptr[k] = '\0';
+    return tmp_ptr;
+}
+
+/**
  * @brief Creates a connection to the storage server.
  * @param hostname the name of the host.
  * @param port the port number.
@@ -25,12 +81,29 @@
  */
 void* storage_connect(const char *hostname, const int port)
 {
+	//check for correct hostname
+	if(!hostname || !strcmp(hostname,"") ||!client_parser(1,MAX_HOST_LEN,hostname)) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return NULL;
+	}
+	
+	//check for correct size for port no.
+	if(port >= pow(10,8)) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return NULL;
+	}
+	
 	/// Create a socket.
 	int sock = socket(PF_INET, SOCK_STREAM, 0);
 	if (sock < 0) {
-	errno = ERR_CONNECTION_FAIL; ///set errno to ERR_CONNECTION_FAIL due to a failure in the connection
+		//set errno to ERR_CONNECTION_FAIL due to a failure in the connection
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Cannot connect to server @ %s:%d. Error code: %d.\n\n",
+		hostname, port, errno);
 		return NULL;
-        }
+    	}
 
 	/// Get info about the server.
 	struct addrinfo serveraddr, *res;
@@ -41,12 +114,18 @@
 	
 	if(snprintf(portstr, sizeof portstr, "%d", port) < 0) {
 	///unknown error might happen due to a failed attempt to create a string with certain with the port number
-	return NULL; 
+	errno = ERR_UNKNOWN;
+	printf("\n>Cannot connect to server @ %s:%d. Error code: %d.\n\n",
+			hostname, port, errno);
+	return NULL;
 	}
 	
 	int status = getaddrinfo(hostname, portstr, &serveraddr, &res);
 	if (status != 0) {
 		///unable to return a pointer to a linked list of addrinfo
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Cannot connect to server @ %s:%d. Error code: %d.\n\n",
+				hostname, port, errno);
 		return NULL;
 	}
 
@@ -54,9 +133,14 @@
 	status = connect(sock, res->ai_addr, res->ai_addrlen);
 	if (status != 0) {
 		///unable to connect to server based on file descriptor of socket
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Cannot connect to server @ %s:%d. Error code: %d.\n\n",
+				hostname, port, errno);
+	
 		return NULL;
 	}
 	
+	client_info[0] = true;
 	return (void*) sock;
 }
 
@@ -72,7 +156,30 @@
 int storage_auth(const char *username, const char *passwd, void *conn)
 {
 
+	if(!conn) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter. Error code: %d\n\n",errno);
+		return -1;
+	}
+	//check for correct username
+	if(!username || !strcmp(username,"") ||!client_parser(1,MAX_USERNAME_LEN,username)) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
+	
+	if(!passwd || !strcmp(passwd,"")) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
 
+	if(!client_info[0]) {
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Connection Fail. Error code: %d\n\n",errno);
+		return -1;
+	}
+
 	/// Connection is really just a socket file descriptor.
 	int sock = (int)conn;
 
@@ -81,15 +188,36 @@
 	memset(buf, 0, sizeof buf);
 	char *encrypted_passwd = generate_encrypted_password(passwd, NULL);
 
+	//check for correct password
+	if(strlen(encrypted_passwd) > MAX_ENC_PASSWORD_LEN) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
+	
 	if(snprintf(buf, sizeof buf, "AUTH %s %s\n", username, encrypted_passwd) < 0 ){
-	errno = ERR_UNKNOWN;	
+	errno = ERR_UNKNOWN;
+	printf("\n>Failed to authenticate with username '%s' and password '%s'. Error code: %d.\n\n", username, passwd, errno);
 	return -1;		
 	}
-
+	
 	if (sendall(sock, buf, strlen(buf)) == 0 && recvline(sock, buf, sizeof buf) == 0) {
+		if(!strcmp(buf,"_1")){
+			errno = ERR_AUTHENTICATION_FAILED;
+			printf("\n>Failed to authenticate with username '%s' and password '%s'. Error code: %d.\n\n", username, passwd, errno);
+			return -1;		
+		}
+		else if(!strcmp(buf,"_0")){
+			errno = ERR_UNKNOWN;
+			printf("\n>Failed to authenticate with username '%s' and password '%s'. Error code: %d.\n\n", username, passwd, errno);
+			return -1;		
+		}
+		client_info[1] = true;
 		return 0;
 	}
-
+	
+	errno = ERR_CONNECTION_FAIL;
+	printf("\n>Failed to authenticate with username '%s' and password '%s'. Error code: %d.\n\n", username, passwd, errno);
 	return -1;
 }
 
@@ -103,23 +231,88 @@
  */
 int storage_get(const char *table, const char *key, struct storage_record *record, void *conn)
 {
+
+	if(!conn) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter. Error code: %d\n\n",errno);
+		return -1;
+	}
+
+	//check for correct table name
+	if(!table || !strcmp(table,"")||!client_parser(1,MAX_TABLE_LEN,table)) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
+	//check for correct key format
+	else if(!key || !strcmp(key,"")||!client_parser(1,MAX_KEY_LEN,key)) {
+			errno = ERR_INVALID_PARAM;
+			printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+			return -1;
+		}
+	//check for correct key format
+	else if(!record) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
+	if(!client_info[0]) {
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Connection Fail. Error code: %d\n\n",errno);
+		return -1;
+	}
+	
+	if(!client_info[1]) {
+		errno = ERR_NOT_AUTHENTICATED;
+		printf("\n>Authentication Fail. Error code: %d\n\n",errno);
+		return -1;
+	}
+
+
 	/// Connection is really just a socket file descriptor.
 	int sock = (int)conn;
 
 	/// Send some data.
 	char buf[MAX_CMD_LEN];
 	memset(buf, 0, sizeof buf);
-	snprintf(buf, sizeof buf, "GET %s %s\n", table, key);
+	if(snprintf(buf, sizeof buf, "GET %s %s\n", table, key) < 0) {
+		errno = ERR_UNKNOWN;
+		printf("\n>Failed to get. Error code:%d",  errno);
+		return -1;
+	}
 	if (sendall(sock, buf, strlen(buf)) == 0 && recvline(sock, buf, sizeof buf) == 0) {
 		strncpy(record->value, buf, sizeof record->value);
+		//check for what type of error, or even if there was an error
+		if(!strcmp(buf,"_2")){
+			errno = ERR_KEY_NOT_FOUND;
+			printf("\n>Failure to get value. Key not Found! Error code: %d.\n\n", errno);
+			return -1;
+		}
+		else if(!strcmp(buf,"_3")){
+			errno = ERR_TABLE_NOT_FOUND;
+			printf("\n>Failure to get value. Table not Found! Error code: %d.\n\n", errno);
+			return -1;
+		}	
+		else if(!strcmp(buf,"_0")){
+			errno = ERR_UNKNOWN;
+			printf("\n>Failed to get value. Error code: %d.\n\n", errno);
+			return -1;		
+		}
+		
+		char *tmp = strtok(buf,",");
+		memset(record->metadata,0,sizeof(record->metadata));
+		*(record->metadata) = atoi(tmp);
+		char *tmp2 = strtok(NULL,"\0");
+		strncpy(record->value, tmp2, sizeof (record->value));
 		return 0;
 	}
-	
 
+	errno = ERR_CONNECTION_FAIL;;
+	printf("\n>Failure to get value. Error code: %d.\n\n", errno);
 	return -1;
 }
 
-
+       
 /**
  * @brief gives command to set a certain record stored in server.
  * @param table is the particular table containing the record.
@@ -131,33 +324,211 @@
  */
 int storage_set(const char *table, const char *key, struct storage_record *record, void *conn)
 {
+	
+	if(!conn) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter. Error code: %d\n\n",errno);
+		return -1;
+	}
+	//check for correct table name
+	if(!table || !strcmp(table,"") || !client_parser(1,MAX_TABLE_LEN,table)) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
+	//check for correct key format
+	else if(!key || !strcmp(key,"") || !client_parser(1,MAX_KEY_LEN,key)) {
+		errno = ERR_INVALID_PARAM;
+		printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+		return -1;
+	}
+	if(!client_info[0] || !conn) {
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Connection Fail. Error code: %d\n\n",errno);
+		return -1;
+	}
+	
+	if(!client_info[1]) {
+		errno = ERR_NOT_AUTHENTICATED;
+		printf("\n>Authentication Fail. Error code: %d\n\n",errno);
+		return -1;
+	}
+
 	/// Connection is really just a socket file descriptor.
 	int sock = (int)conn;
 
+	char *tmp_ptr;
+	if(!record)
+		tmp_ptr = "_";
+	else 
+		tmp_ptr = record->value;
 	/// Send some data.
 	char buf[MAX_CMD_LEN];
 	memset(buf, 0, sizeof buf);
-	snprintf(buf, sizeof buf, "SET %s %s %s\n", table, key, record->value);
+	if(!record){
+	if(snprintf(buf, sizeof buf, "SET 0,%s %s,%s\n",table, key, tmp_ptr) < 0 ) {
+	errno = ERR_UNKNOWN;
+	printf("\n> Failure to set value. Error code:%d", errno);
+	return -1;
+	}
+	}
+	else
+		snprintf(buf, sizeof buf, "SET %d,%s %s,%s\n", *(record->metadata),table, key, tmp_ptr);
 	if (sendall(sock, buf, strlen(buf)) == 0 && recvline(sock, buf, sizeof buf) == 0) {
+		
+		if(!strcmp(buf,"_2")){
+			errno = ERR_KEY_NOT_FOUND;
+			printf("\n>Failure to set value. Key not Found! Error code: %d.\n\n", errno);
+			return -1;
+		}
+		else if(!strcmp(buf,"_3")){
+			errno = ERR_TABLE_NOT_FOUND;
+			printf("\n>Failure to set value '%s'. Table not Found! Error code: %d.\n\n",record->value, errno);
+			return -1;
+		}
+		else if(!strcmp(buf,"_4")){
+			errno = ERR_INVALID_PARAM;
+			printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+			return -1;
+		}
+		else if(!strcmp(buf,"_0")){
+			errno = ERR_UNKNOWN;
+			printf("\n>Failed to set value. Error code: %d.\n\n",errno);
+			return -1;		
+		}
+		else if(!strcmp(buf,"_5")){
+			errno = ERR_TRANSACTION_ABORT;
+			printf("\n>Failed to set value. Error code: %d.\n\n",errno);
+			return -1;
+		}
+		
 		return 0;
 	}
-
+	
+	errno = ERR_UNKNOWN;
+	printf("\n>Failure to set value. Error code: %d.\n\n", errno);
 	return -1;
 }
+int storage_query(const char *table, const char *predicates, char **keys, const int max_keys, void *conn) {
 
+	if(!conn) {
+			errno = ERR_INVALID_PARAM;
+			printf("\n>Invalid Parameter. Error code: %d\n\n",errno);
+			return -1;
+		}
+		//check for correct table name
+		if(!table || !strcmp(table,"") || !client_parser(1,MAX_TABLE_LEN,table)) {
+			errno = ERR_INVALID_PARAM;
+			printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+			return -1;
+		}
+		//check for correct predicates format
+		else if(!predicates || !strcmp(predicates,"")) {
+			errno = ERR_INVALID_PARAM;
+			printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+			return -1;
+		}
+		if(max_keys < 0) {
+			errno = ERR_INVALID_PARAM;
+			printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+			return -1;	
+		}
+		if(!client_info[0] || !conn) {
+			errno = ERR_CONNECTION_FAIL;
+			printf("\n>Connection Fail. Error code: %d\n\n",errno);
+			return -1;
+		}
+		
+		if(!client_info[1]) {
+			errno = ERR_NOT_AUTHENTICATED;
+			printf("\n>Authentication Fail. Error code: %d\n\n",errno);
+			return -1;
+		}
 
-/**
- * @brief Closes connection
- * @param conn is the connection socket.
- * @return 0
- * returns 0 if successful
- */
+		/// Connection is really just a socket file descriptor.
+		int sock = (int)conn;
+
+		/// Send some data.
+		char buf[MAX_CMD_LEN];
+		memset(buf, 0, sizeof buf);
+		if(snprintf(buf, sizeof buf, "QUERY %s,%s*%d\n", table, predicates, max_keys) < 0 ) {
+		errno = ERR_UNKNOWN;
+		printf("\n> Failure to set value. Error code:%d", errno);
+		return -1;
+		}
+		char buf2[MAX_CMD_LEN];
+		memset(buf2, 0, sizeof buf2);
+		if (sendall(sock, buf, strlen(buf)) == 0 && recvline(sock, buf2, sizeof(buf2)) == 0) {
+			//check for what type of error, or even if there was an error
+			if(!strcmp(buf2,"_2")){
+				errno = ERR_KEY_NOT_FOUND;
+				printf("\n>Failure to set value. Key not Found! Error code: %d.\n\n", errno);
+				return -1;
+			}
+			else if(!strcmp(buf2,"_3")){
+				errno = ERR_TABLE_NOT_FOUND;
+				printf("\n>Failure to set value. Table not Found! Error code: %d.\n\n", errno);
+				return -1;
+			}
+			else if(!strcmp(buf2,"_4")){
+				errno = ERR_INVALID_PARAM;
+				printf("\n>Invalid Parameter was entered. Error code: %d\n\n",errno);
+				return -1;
+			}
+			else if(!strcmp(buf2,"_0")){
+				errno = ERR_UNKNOWN;
+				printf("\n>Failed to query. Error code: %d.\n\n", errno);
+				return -1;		
+			}
+			
+			//parse all the data and put it into the char** for the user
+			int y;
+			char copy_buf[1024];
+			char copy_no[1024];
+			strncpy(copy_buf,buf2,strlen(buf2));
+			snprintf(copy_no,1024,"%c\0",copy_buf[0]);
+			int number = atoi(copy_no);
+			int d = 1;
+			for (y = 0; y < number; y++){
+				d++;
+				int t = 0;
+				char tmp_char[1024];
+				memset(tmp_char,0,sizeof(tmp_char));
+				if(copy_buf[d] == '\0')
+					break;
+				for(d; copy_buf[d] != '\0' && copy_buf[d] != ',';d++){
+					tmp_char[t] = copy_buf[d];
+					t++;
+				}
+				keys[y] = tmp_char;
+			}	
+
+			return number;
+		}
+		
+		errno = ERR_UNKNOWN;
+		printf("\n>Failure to set value. Error code: %d.\n\n", errno);
+		return -1;
+
+}
 int storage_disconnect(void *conn)
 {
+	if(!conn) {
+	errno = ERR_INVALID_PARAM;
+	printf("\n>Invalid Parameter. Error code: %d.\n\n", errno);
+	return -1;
+	}
 	/// Cleanup
+	else if(!client_info[0]){
+		errno = ERR_CONNECTION_FAIL;
+		printf("\n>Failure Connect. Error code: %d.\n\n", errno);
+		return -1;
+	}
 	int sock = (int)conn;
 	close(sock);
-
+	client_info[0] = false;
+	client_info[1] = false;
 	return 0;
+	
 }
 
Index: utils.h
===================================================================
--- utils.h	(revision 1)
+++ utils.h	(revision 66)
@@ -21,6 +21,7 @@
 
 extern FILE *file_ptr;
 
+
 /**
  * @brief Any lines in the config file that start with this character 
  * are treated as comments.
@@ -52,67 +53,112 @@
 #define DBG(x)  {printf x; fflush(stdout);}
 #endif
 
-/**
- * @brief A struct to store config parameters.
- */
 
-	//the individual data elements
-	//city is key
-	//popu is population
-	//next is next record_element in linked list
-	//declare typedef for record_element
-typedef struct record_element record_element;
+//struct of data column containing int and char value, use whichever needed.
+//use char type of data stored in column is char, else use int.
+//contains pointer to next column
 
-struct record_element
-{
-	record_element* next;
-	char *key;
-	char *value;
-};
+typedef struct column_struct column_struct;
+typedef struct record_struct record_struct;
 
-	//Done by Vincent Aulia
+	struct column_struct {
+	char column_name[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];//COLUMN NAME
+        char value[MAX_COLUMNS_PER_TABLE][MAX_VALUE_LEN];
+        int type[MAX_COLUMNS_PER_TABLE];
+	};
 
-	//a function to make an int key from string key
-int keymaker(char* index);
+//struct containing record
+//record struct contains 	key
+//				pointer to next record
+//				pointer to first column data
+	struct record_struct {
+	char key[MAX_KEY_LEN]; //RECORD KEY
+	int metadata; // metadata
+	record_struct *next; //POINTER TO NEXT RECORD KEY
+	column_struct column; //column struct containing all the columns
+	};
 
-	//a function to insert record to table
-void record_insert(int address, char *key, char *value, record_element** table);
 
-	//a function to return THE ADDRESS of a record element
-record_element* key_search(char* key, record_element** table, int index);
 
-	//a function to search THE LOCATION INSIDE THE ADDRESS a record element
-record_element* record_search(char* key, record_element** table, int index);
+//struct defining a table
+	typedef struct table{
+	//should use MAX_TABLE_LEN but server.c doesnt include storage.h so put 20
+	char table_name[MAX_TABLE_LEN];
+	record_struct* RecordStruct[1000];
+	}table;
 
-	//a function to delete a record element
-bool record_delete(char* key, record_element** table, int index);
+//struct to store list of tables already generated
+	typedef struct table_list{
+	//should use MAX_TABLES but server.c doesnt include storage.h so put 100
+	table Table[100];
+	}table_list;
+	
+	
 
+
+/**
+ * @brief hashing function
+ * @param index The key to be inserted 
+ * @return Returns hashed int key
+ */
+int keymaker(const char* index);
+
+typedef struct table_params table_params;
+/**
+ * @brief struct for storing information about column names in tables in configuration file
+ * 
+ *
+ */
+struct table_params {
+	//table name
+	char table_name[MAX_TABLE_LEN];
+	//table columns
+	char table_columns[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];
+	//column types
+	int column_types[MAX_COLUMNS_PER_TABLE];
+};
+typedef struct config_params config_params;
+/**
+ * @brief struct for storing information about the current configuration file
+ * 
+ * */
+
 struct config_params {
 	/// The hostname of the server.
 	char server_host[MAX_HOST_LEN];
 
 	/// The listening port of the server.
 	int server_port;
+	
+	/// Concurrency setting number
+	int concurrency;
 
 	/// The storage server's username
 	char username[MAX_USERNAME_LEN];
 	
-	char table[MAX_TABLES][MAX_TABLE_LEN];
+	/// The user's password
+	char pass_[MAX_ENC_PASSWORD_LEN];
 	
+	char table_name[MAX_TABLES][MAX_TABLE_LEN];
+	
+	struct table_params tablepara[MAX_TABLES];	
+		
 	bool duplicateparam;
 		
 	bool duplicatetable;
-	
-	/// The user's password
-	char pass_[MAX_ENC_PASSWORD_LEN];
-
 	/// The directory where tables are stored.
 //	char data_directory[MAX_PATH_LEN];
 };
 
 /**
+ * @brief Function that determines whether a character is alphanumeric character or not by using ASCII values.
+ * @param str_ptr The character that's being evaluated.
+ * @ret If the character is alphanumeric, return true. If not, return false.
+ */
+bool is_alpha(char str_ptr);
+/**
  * @brief Exit the program because a fatal error occured.
- *
+ *[i+1
  * @param msg The error message to print.
  * @param code The program exit return value.
  */
@@ -168,4 +214,52 @@
  */
 char *generate_encrypted_password(const char *passwd, const char *salt);
 
+/**
+ * @brief struct for storing information about the query parameters
+ * 
+ * */
+struct query_params
+{
+    char column_names[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];
+    char operator[MAX_COLUMNS_PER_TABLE];
+    char value[MAX_COLUMNS_PER_TABLE][MAX_VALUE_LEN];
+};
+
+/**
+ * @brief This is a function that parses the query command from client side to be used in server side
+ * 
+ * @param unparsed_ pointer to the unparsed string
+ * @param query_params *qparams pointer to the struct where query parameters are stored
+ * @return pointer to the parsed string
+ */
+char* query_parsing(char* unparsed_, struct query_params *qparams);
+
+/**
+ * @brief struct for storing information about the set parameters
+ * 
+ * */
+struct set_params
+{
+    char column_names[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];
+    char value[MAX_COLUMNS_PER_TABLE][MAX_VALUE_LEN];
+};
+
+/**
+ * @brief This is a function that parses the set command from client side to be used in server side
+ * 
+ * @param unparsed_ pointer to the unparsed string
+ * @param set_params *sparams pointer to the struct where set parameters are stored
+ * @return pointer to the parsed string
+ */
+char* set_parsing(char* unparsed_, struct set_params *sparams);
+
+int record_query(char* tableName, char* predicates, int max_keys, char* keys_found, table_list* list);
+int insert_table(config_params params,table_list *table_ptr);
+int insert_key(const char *table, const char *key, const char* value, table_list *table_ptr, config_params params, int metadata);
+int create_record(int option,int i,char *key, char *value, table_list *List, config_params params, int metadata);
+int delete_record(table_list* list, char* table, char* key);
+int record_get(char* table, char* key, table_list* list, char *append, int *metadata);
+bool find_table(char* table, table_list* table_ptr);
+record_struct* find_record(char *table, char *key, table_list *list);
+
 #endif
Index: server.c
===================================================================
--- server.c	(revision 1)
+++ server.c	(revision 66)
@@ -8,8 +8,6 @@
  * The storage server should be able to communicate with the client
  * library functions declared in storage.h and implemented in storage.c.
  */
-
-
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -23,22 +21,115 @@
 #include <signal.h>
 #include "utils.h"
 #include <time.h>
+#include <stdbool.h>
+#include <pthread.h>
+
 #define LOGGING 0
 #define MAX_LISTENQUEUELEN 20	///< The maximum number of queued connections.
+struct set_params sparams;
+struct query_params qparams;
+struct config_params params;
+table_list List;
+FILE *file;
+int *connfdp;
+int handle_command(FILE *file, int sock, char *cmd,  table_list * List, struct config_params params, struct set_params sparams, struct query_params qparams);
+/**
+ * @brief Structure storing information for each thread
+ * 
+ */
+struct _ThreadInfo { 
+  struct sockaddr_in clientaddr;
+  socklen_t clientaddrlen; 
+  int clientsock; 
+  pthread_t theThread; 
+}; 
+typedef struct _ThreadInfo *ThreadInfo;
 
+/*  Thread buffer, and circular buffer fields */ 
+ThreadInfo runtimeThreads[MAX_CONNECTIONS]; 
+unsigned int botRT = 0, topRT = 0;
 
-//function that checks whether table exists
-bool find_table(char * table, struct config_params params) {
-	
-	int i;	
-	for(i = 0; (i < MAX_TABLES) && params.table[i]; i++) {
-		if (strcmp(table, params.table[i]) == 0){
-			return true;
+/* Mutex initializations*/ 
+pthread_mutex_t  printMutex    = PTHREAD_MUTEX_INITIALIZER;
+pthread_mutex_t conditionMutex = PTHREAD_MUTEX_INITIALIZER;
+pthread_mutex_t handle_cmd_lock = PTHREAD_MUTEX_INITIALIZER;
+pthread_cond_t  conditionCond  = PTHREAD_COND_INITIALIZER;
+
+/**
+ * @brief Function accessing threadinfo struct
+ * 
+ * @param void There're no parameter inputs
+ * @ret Returns a pointer to the threadinfo struct
+ */
+ThreadInfo getThreadInfo(void) { 
+  ThreadInfo currThreadInfo = NULL;
+
+  /* Wait as long as there are no more threads in the buffer */ 
+  pthread_mutex_lock( &conditionMutex ); 
+  while (((botRT+1)%MAX_CONNECTIONS)==topRT)
+    pthread_cond_wait(&conditionCond,&conditionMutex); 
+  
+  /* At this point, there is at least one thread available for us. We
+     take it, and update the circular buffer  */ 
+  currThreadInfo = runtimeThreads[botRT]; 
+  botRT = (botRT + 1)%MAX_CONNECTIONS;
+
+  /* Release the mutex, so other clients can add threads back */ 
+  pthread_mutex_unlock( &conditionMutex ); 
+  
+  return currThreadInfo;
+}
+
+/**
+ * @brief Function called when thread is about to finish -- unless it is
+   called, the ThreadInfo assigned to it is lost
+ * 
+ * @param Threadinfo the pointer to the threadinfo struct is passed in
+ * @ret void There's no return 
+ */
+void releaseThread(ThreadInfo me) {
+  pthread_mutex_lock( &conditionMutex ); 
+  assert( botRT!=topRT ); 
+ 
+  runtimeThreads[topRT] = me; 
+  topRT = (topRT + 1)%MAX_CONNECTIONS; 
+
+  /* tell getThreadInfo a new thread is available */ 
+  pthread_cond_signal( &conditionCond ); 
+
+  /* Release the mutex, so other clients can get new threads */ 
+  pthread_mutex_unlock( &conditionMutex ); 
+}
+
+void * threadCallFunction(void *arg) { 
+	ThreadInfo tiInfo = (ThreadInfo)arg;
+	int clientsock = tiInfo->clientsock;
+	pthread_detach(pthread_self());
+	free(arg);
+	int wait_for_commands = 1;
+	do {
+		// Read a line from the client.
+		char cmd[MAX_CMD_LEN];
+		memset(cmd,0,MAX_CMD_LEN);
+		int status = recvline(clientsock, cmd, MAX_CMD_LEN);
+		if (status != 0) {
+		// Either an error occurred or the client closed the connection.
+		wait_for_commands = 0;
+		} else {
+			
+			// Handle the command from the client.
+			pthread_mutex_lock(& handle_cmd_lock);
+			status = handle_command(file, clientsock, cmd, &List, params, sparams, qparams);
+			pthread_mutex_unlock(& handle_cmd_lock);
+			if (status != 0)
+				wait_for_commands = 0; // Oops.  An error occured.
 		}
-	}
+	} while (wait_for_commands);
 
-		return false;
-}	
+	close(tiInfo->clientsock);
+	releaseThread( tiInfo ); 
+	return NULL;
+}
 
 
 /**
@@ -48,147 +139,309 @@
  * @param cmd The command received from the client.
  * @return Returns 0 on success, -1 otherwise.
  */
-int handle_command(FILE *file, int sock, char *cmd, record_element **data,struct config_params params)
+int handle_command(FILE *file, int sock, char *cmd,  table_list * List, struct config_params params, struct set_params sparams, struct query_params qparams)
 {
+	
+		char output2[1024];
 	char *command = strtok(cmd," ");
 
 	if(command) {
 
 		if(!strcmp(command,"AUTH")) {
 			char *username = strtok(NULL," ");
-			char *password = strtok(NULL,"\n");
-
+			char *password = strtok(NULL,"\0");
+			sprintf(output2,"server_auth - username:%s and password: %s\n", username,password);
+			logger(file,output2);
 			if(!strcmp(username, params.username) && !strcmp(password,params.pass_))	{
-
-				if(sendall(sock, "\n", 1)){
-
-						errno = ERR_UNKNOWN;
-						return -1;
+				if(sendall(sock, "0\n", 2)){
+					errno = ERR_UNKNOWN;
+					
+					return -1;
 				}
+				
 				return 0;
+				}
 
-			}
-
-			errno = ERR_AUTHENTICATION_FAILED;
+				errno = ERR_AUTHENTICATION_FAILED;
+				if(sendall(sock, "_1\n", 3)){
+					errno = ERR_UNKNOWN;
+					return -1;
+				}
+			
 			return 0;
-
 		}
 	
 		else if(!strcmp(command,"SET"))
 
 		{	//read data and insert it into respective variable
 			//variable to be used
-			char *table = strtok(NULL," ");
-			char *key = strtok(NULL," ");
-			char *value = strtok(NULL,"\n");
+			char *meta = strtok(NULL,",");
+			char *table_ = strtok(NULL," ");
+			char *key = strtok(NULL,",");
+			char *value = strtok(NULL,"\0");
+			
+			sprintf(output2,"server_set - Table:%s, Key:%s and Value:%s\n",table_, key, value);
+			logger(file,output2);
+			//checking whether table exists	
+			if (find_table(table_,List)){
+				
+				//checking whether user wants key to be deleted
+				if(!strcmp(value, "_")){
 
-			//checking whether table exists
-			if(find_table(table,params)){
+					int d = delete_record(List,table_,key);
+					//key doesn't exist
+					if(d != 0)
+					{
+						//table doesn't exist
+						if(d == -2) {
+							errno = ERR_KEY_NOT_FOUND;
+							if(sendall(sock, "_2\n", 3)){
+								
+								return -1;
+							}
+							
+							return 0;
+						}
 
-				//check whether user wants key to be deleted
-				if(!value){
-								
-				if(!record_delete(key, data, keymaker(key))) {
+						sendall(sock, "_0\n", 3);
+						
+						return 0;
+					}
 					
-					//key doesn't exist
-					errno = ERR_KEY_NOT_FOUND;
-					return -1;
+					//key exists and it has been deleted
+					if(sendall(sock, "_\n", 2)){
+						
+						return -1;
 					}
-
-				//key exists and it has been deleted
-				if(sendall(sock, "\n", 1)){
-
-					errno = ERR_UNKNOWN;
-					return -1;
+					
+					return 0;
+						
 				}
-				return 0;
+				//converting necessary parameters to be used in logger function
+				char* parsed_value = set_parsing (value, &sparams);
+				if (parsed_value == NULL)
+				{
+					errno = ERR_INVALID_PARAM;
+					if(sendall(sock, "_4\n", 3)){
+						errno = ERR_UNKNOWN;
+						
+						return -1;
+					}
+					
+					return 0;
+				}
 				
+				char value2[1024];
+				snprintf(value2,sizeof(value2),"%s",parsed_value);
+				//Setting the record
+				int meta2;
+				if(meta)
+				meta2 = atoi(meta);
+				else meta2 = 0;
+				int s2 = insert_key(table_,key,value2,List, params,meta2);
+				if(s2 != 0)
+				{
+					   //table doesn't exist
+					if(s2 == -3) {
+						errno = ERR_TABLE_NOT_FOUND;
+						if(sendall(sock, "_3\n", 3)){
+							
+							return -1;
+						}
+						
+						return 0;
+					}
+										
+					if(s2 == -4) {
+					//invalid parameter
+					if(sendall(sock, "_4\n", 3)){
+						
+						return -1;
 				}
-				//change keys value to the one specified
-				//create pointer to record_element*
-				record_element *tmp_ptr;
-				tmp_ptr = key_search(key, data, keymaker(key));
-
-				//check whether it exists
-				if(tmp_ptr) {
-				//change value inside that parameter
-				tmp_ptr->value = value;
 				}
-
-				else {
-
-					record_insert(keymaker(key), key, value, data);
-
+				  if(s2 == -5) {
+					//transaction abort
+					if(sendall(sock, "_5\n", 3)){
+						
+						return -1;
+					}
 				}
-
-				if(sendall(sock, "\n", 1)){
-
-					errno = ERR_UNKNOWN;
-					return -1;
-				}
+				
 				return 0;
+			}
 
-			}	
+			sendall(sock, "_\n", 2);
+			
+			return 0;
+	}
+								
+			
 			//table doesn't exist
 			errno = ERR_TABLE_NOT_FOUND;
-			return -1;
+			if(sendall(sock, "_3\n", 3)){
+				errno = ERR_UNKNOWN;
+				
+				return -1;
+			}
+			
+			return 0;
+			
 		}
 
 		else if(!strcmp(command,"GET")) 
 	
 		{
-			
 			//read data and insert it into respective variable
 			//variable to be used
-			char *table = strtok(NULL," ");
-			char *key = strtok(NULL," ");
-			char *value = strtok(NULL,"\n");
-
-			//checking whether table exists
-			if(find_table(table,params)){
-		
-				//check whether user wants key to be deleted
-				if(!value){
-				//search for element
-				record_element *tmp_ptr;
-				tmp_ptr = key_search(key, data, keymaker(key));	
-				//check whether key exists			
-				if(!tmp_ptr) {
-
-				errno = ERR_KEY_NOT_FOUND;
-				return -1;
-
-				}
+			char *table_ = strtok(NULL," ");
+			char *key = strtok(NULL,"\0");
+			sprintf(output2,"server_get - Table:%s and Key:%s\n", table_,key);
+			logger(file,output2);
+			char append[1024];
+			memset(append,0,sizeof(append));
+			//check if table exits
+			if(find_table(table_,List)) {
+				int metadata_ptr = 0;
+				int status = record_get(table_, key, List, append,&metadata_ptr);
 				
-				char buf[MAX_CMD_LEN];
-				snprintf(buf,sizeof(buf),"%s",tmp_ptr->value);
-				//send the requested information
-				if(sendall(sock, buf, strlen(buf))) {
-				
-				//error encountered when sending all the data
-				errno = ERR_UNKNOWN;
-				return -1;				
-			
+				if(status != 0) {
+					//table doesn't exist
+					if(status == -2) {
+						errno = ERR_KEY_NOT_FOUND;
+						if(sendall(sock, "_2\n", 3)){
+							
+							return -1;
+						}
+						
+						return 0;
+					}
+					sendall(sock, "_0\n", 3);
+					
+					return 0;
+				}					
+					char new[1024];
+					memset(new,0,sizeof(new));
+					snprintf(new,1024, "%d,%s\n",metadata_ptr,append);
+					if(sendall(sock, new, strlen(new))){
+						errno = ERR_UNKNOWN;
+						
+						return -1;
+					}
+					
+					return 0;
+								
 				}
-				//everything worked perfectly fine
-				if(sendall(sock, "\n", 1)){
-
-					errno = ERR_UNKNOWN;
-					return -1;
-				}
-				return 0;
-			}	
-			//table doesn't exist
+				//table doesn't exist
 			errno = ERR_TABLE_NOT_FOUND;
-			return -1;
+			if(sendall(sock, "_3\n", 3)){
+				errno = ERR_UNKNOWN;
+				
+				return -1;
+			}
 			
+			return 0;
+			
+								
 		}
-	}
+		
+		else if(!strcmp(command,"QUERY")) 
+			
+				{
+					//read data and insert it into respective variable
+					//variable to be used
+					char *table_ = strtok(NULL,",");
+					char predicates[1024];
+					strncpy(predicates,strtok(NULL,"*"),sizeof(predicates));
+					char *no_keys = strtok(NULL,"\0");
+					int max_keys = atoi(no_keys);
+					//parsing predicates
+					char *parsed_ = query_parsing(predicates, &qparams);
+										
+					if (parsed_ == NULL)
+					{
+						errno = ERR_INVALID_PARAM;
+						if(sendall(sock, "_4\n", 3)){
+							
+							return -1;
+						}
+						
+						return 0;
+					}
+					
+					char parsed_predicates[1024];
+					strncpy(parsed_predicates,parsed_,sizeof(parsed_predicates));
+					
+					sprintf(output2,"server_query - Table:%s , predicates:%s and max keys:%s\n", table_,parsed_predicates,no_keys);
+					logger(file,output2);
+					//checking whether table exists
+					if(find_table(table_,List)) {
+						
+						char new[1024];
+						snprintf(new,1024,"%s",parsed_predicates);
+						char keys_found[1024];
+						memset(keys_found,0,sizeof(keys_found));
+						int status = record_query(table_,new,max_keys,keys_found,List);
+						
+						if(status < 0) {
+							
+							if(status == -2) {
+								errno = ERR_KEY_NOT_FOUND;
+								if(sendall(sock, "_2\n", 3)){
+									
+									return -1;
+								}
+								
+								return 0;
+							}
+							
+							if(status == -4) {
+								//invalid parameter
+								if(sendall(sock, "_4\n", 3)){
+									
+									return -1;
+							    }
+								
+								return 0;
+							}
+							
+							sendall(sock, "_0\n", 3);
+							
+							return 0;
+						}
+					
+						char send[1024];
+						memset(send,0,sizeof(send));
+						snprintf(send,1024,"%d,%s\n",status,keys_found);
+						if(sendall(sock, send, strlen(send))){
+							errno = ERR_UNKNOWN;
+							
+							return -1;
+						}
+						
+						return 0;
+					}
+						//table doesn't exist
+						errno = ERR_TABLE_NOT_FOUND;
+						if(sendall(sock, "_3\n", 3)){
+						errno = ERR_UNKNOWN;
+						
+						return -1;
+					}
+					
+					return 0;
 
+				}
+
 	}
+	
+	else 
+	{
+	errno = ERR_UNKNOWN;
+	sendall(sock,"_0\n",3);
+	
+	return 0;
+	}
 
-	errno = ERR_UNKNOWN;
-	return -1;
 }
 
 /**
@@ -199,17 +452,22 @@
  * commands from clients.
  */
 int main(int argc, char *argv[])
-{
-	struct config_params params;
+{	
+	
 	memset(&params, 0, sizeof(params));
-        	
-	//declare data structure holding all values
-	record_element *table[997];
-
+	params.concurrency = -1;
+	
+	memset(&List,0,sizeof(table));
 	char output2[1000],output3[1000],output4[1000];
 	
-	FILE *file;
+	//Query parameters
+	
+	memset(&qparams, 0, sizeof(qparams));
+	
+	//Set parameters
 
+	memset(&sparams, 0, sizeof(sparams));
+
 	if (LOGGING == 0) {
 
 	file = NULL;
@@ -236,30 +494,37 @@
 	// Process command line arguments.
 	// This program expects exactly one argument: the config file name.
 	assert(argc > 0);
+	
 	if (argc != 2) {
 		printf("Usage %s <config_file>\n", argv[0]);
 		exit(EXIT_FAILURE);
 	}
 	char *config_file = argv[1];
-
+	
 	// Read the config file.
 	int status = read_config(config_file, &params);
-
+	if(params.concurrency == 2 || params.concurrency == 3)
+		exit(2);
 	if (status != 0) {
 		printf("Error processing config file.\n");
 		exit(EXIT_FAILURE);
 	}
+	
+	if(insert_table(params, &List) < 0) {
+		exit (-2);
+	}
+	
 	//converting necessary parameters to be used in logger function
 	sprintf(output2,"Server on %s:%d\n", params.server_host, params.server_port);
 	logger(file,output2); 
-
+	
 	// Create a socket.
 	int listensock = socket(PF_INET, SOCK_STREAM, 0);
 	if (listensock < 0) {
 		printf("Error creating socket.\n");
 		exit(EXIT_FAILURE);
 	}
-
+	
 	// Allow listening port to be reused if defunct.
 	int yes = 1;
 	status = setsockopt(listensock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes);
@@ -286,11 +551,45 @@
 		printf("Error listening on socket.\n");
 		exit(EXIT_FAILURE);
 	}
+	
+	if(params.concurrency == 1) {
+	
+	int i;
+	  /* First, we allocate the thread pool */ 
+	for (i = 0; i!=MAX_CONNECTIONS; ++i)
+		runtimeThreads[i] = malloc( sizeof( struct _ThreadInfo ) ); 
 
 	// Listen loop.
 	int wait_for_connections = 1;
 	while (wait_for_connections) {
 		// Wait for a connection.
+			ThreadInfo tiInfo = getThreadInfo(); 
+		    tiInfo->clientaddrlen = sizeof(struct sockaddr_in); 
+		    tiInfo->clientsock = accept(listensock, (struct sockaddr*)&tiInfo->clientaddr, &tiInfo->clientaddrlen);
+		    if (tiInfo->clientsock < 0) {
+		      pthread_mutex_lock( &printMutex ); 
+		      printf("ERROR in connecting to %s:%d.\n", 
+			     inet_ntoa(tiInfo->clientaddr.sin_addr), tiInfo->clientaddr.sin_port);
+		      pthread_mutex_unlock( &printMutex ); 
+		    } else {
+		      pthread_create( &tiInfo->theThread, NULL, threadCallFunction, (void *)tiInfo); 
+		    }
+	}		
+	  /* At the end, wait until all connections close */ 
+	  for (i=topRT; i!=botRT; i = (i+1)%MAX_CONNECTIONS)
+		pthread_join(runtimeThreads[i]->theThread, 0 ); 
+	
+	  /* Deallocate all the resources */ 
+	  for (i=0; i!=MAX_CONNECTIONS; i++)
+		free( runtimeThreads[i] ); 	
+	}
+	  else {
+  
+  
+  // Listen loop.
+	int wait_for_connections = 1;
+	while (wait_for_connections) {
+		// Wait for a connection.
 		struct sockaddr_in clientaddr;
 		socklen_t clientaddrlen = sizeof clientaddr;
 		int clientsock = accept(listensock, (struct sockaddr*)&clientaddr, &clientaddrlen);
@@ -299,8 +598,8 @@
 			exit(EXIT_FAILURE);
 		}
 		sprintf(output3,"Got a connection from %s:%d.\n", inet_ntoa(clientaddr.sin_addr), clientaddr.sin_port);
-		logger(file,output3);
-
+		logger(file,output3);	
+		
 		// Get commands from client.
 		int wait_for_commands = 1;
 		do {
@@ -312,7 +611,7 @@
 				wait_for_commands = 0;
 			} else {
 				// Handle the command from the client.
-				int status = handle_command(file, clientsock, cmd, table,params);
+				int status = handle_command(file, clientsock, cmd, &List, params, sparams, qparams);
 				if (status != 0)
 					wait_for_commands = 0; // Oops.  An error occured.
 			}
@@ -323,13 +622,12 @@
 		sprintf(output4,"Closed connection from %s:%d.\n", inet_ntoa(clientaddr.sin_addr), clientaddr.sin_port);
 		logger(file,output4);
 	}
-
-	if(LOGGING == 2 || LOGGING == 1)
+	  }
+	  
+	if(file)
 	fclose(file);
 	// Stop listening for connections.
 	close(listensock);
 
 	return EXIT_SUCCESS;
 }
-
-
Index: default.conf
===================================================================
--- default.conf	(revision 1)
+++ default.conf	(revision 66)
@@ -1,6 +1,8 @@
 server_host localhost
-server_port 1189
+server_port 5628
 username admin
 password xxxnq.BMCifhU
-table marks
-table hehe
+concurrency 1
+table inttbl col:int
+table floattbl col:int
+table strtbl col:char[10]
\ No newline at end of file

Property changes on: storage.h
___________________________________________________________________
Deleted: svn:executable
   - 

Index: Makefile
===================================================================
--- Makefile	(revision 1)
+++ Makefile	(revision 66)
@@ -9,7 +9,7 @@
 
 # Compile flags.
 CFLAGS = -g -Wall
-LDFLAGS = -g -Wall -lcrypt
+LDFLAGS = -g -Wall -lcrypt -lpthread
 
 # Dependencies file
 DEPEND_FILE = depend.mk
